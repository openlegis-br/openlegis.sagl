<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Pasta Digital - Visualização de Processo Legislativo">
    <title id="page-title">Pasta Digital</title>
    
    <!-- Favicon e recursos estáticos serão injetados -->
    <link rel="shortcut icon" type="image/x-icon" href="" id="favicon">
    
    <!-- CSS do Sistema - Preenchidos no servidor para evitar FOUC -->
    <link rel="stylesheet" href="" id="css-bootstrap">
    <link rel="stylesheet" href="" id="css-icons">
    <link rel="stylesheet" href="" id="css-app">
    <link rel="stylesheet" href="" id="css-all">
    
    <style>
        /* ============================================
           ESTILOS DA PASTA DIGITAL
           ============================================
           NOTA: Este template herda automaticamente:
           - Bootstrap CSS (via css-bootstrap)
           - app.css (via css-app) 
           - estilos.css/all.min.css (via css-all)
           
           Estilos aqui são apenas customizações específicas.
           Mudanças em app.css refletem automaticamente via variáveis CSS.
           ============================================ */
        
        :root {
            /* Variáveis Bootstrap do Sistema - Consistência Visual */
            --bs-primary: #44a2d2;
            --bs-secondary: #6c757d;
            --bs-success: #28a745;
            --bs-warning: #ffc107;
            --bs-danger: #dc3545;
            --bs-info: #17a2b8;
            --bs-body-bg: #f8f9fa;
            --bs-body-color: #212529;
            --bs-border-color: #dee2e6;
            --bs-gray-100: #f8f9fa;
            --bs-gray-200: #e9ecef;
            --bs-gray-300: #dee2e6;
            --bs-gray-400: #ced4da;
            --bs-gray-500: #adb5bd;
            --bs-gray-600: #6c757d;
            --bs-gray-700: #495057;
            --bs-gray-800: #343a40;
            --bs-gray-900: #212529;
            --bs-border-radius: 0.375rem;
            --bs-border-radius-sm: 0.25rem;
            --bs-border-radius-lg: 0.5rem;
            --bs-font-sans-serif: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", "Noto Sans", "Liberation Sans", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            --bs-font-size-base: 0.93rem;
            --bs-body-line-height: 1.5;
            --bs-btn-font-size: 13px;
            
            /* Variáveis específicas da Pasta Digital (mantidas para compatibilidade) */
            --primary-blue: var(--bs-primary, #44a2d2);
            --sidebar-width: 380px;
            --header-height: 64px;
            --toolbar-height: 64px;
            --bg-light: var(--bs-body-bg, #f8f9fa);
            --border-color: var(--bs-border-color, #dee2e6);
            --primary-color: var(--bs-primary, #44a2d2);
            --primary-dark: #2d7ba8;
            --secondary-color: var(--bs-secondary, #6c757d);
            --success-color: var(--bs-success, #28a745);
            --warning-color: var(--bs-warning, #ffc107);
            --danger-color: var(--bs-danger, #dc3545);
            --info-color: var(--bs-info, #17a2b8);
            --dark-text: var(--bs-body-color, #212529);
            
            /* Cores da Toolbar - usando variáveis Bootstrap */
            --toolbar-bg: #ffffff;
            --toolbar-border: var(--bs-border-color, #dee2e6);
            --toolbar-text: var(--bs-body-color, #212529);
            --toolbar-btn-bg: var(--bs-gray-100, #f8f9fa);
            --toolbar-btn-hover: var(--bs-gray-200, #e9ecef);
            --toolbar-input-bg: #ffffff;
            --toolbar-badge-bg: linear-gradient(135deg, rgba(68, 162, 210, 0.1) 0%, rgba(68, 162, 210, 0.15) 100%);
            --toolbar-badge-text: var(--bs-primary, #44a2d2);
            --toolbar-separator: var(--bs-border-color, #dee2e6);
            
            /* Cores do Monitor - usando variáveis Bootstrap */
            --monitor-overlay-bg: rgba(255, 255, 255, 0.95);
            --monitor-card-bg: #ffffff;
            --monitor-card-border: var(--bs-border-color, #dee2e6);
            --monitor-title-color: var(--bs-primary, #44a2d2);
            --monitor-text-color: var(--bs-gray-700, #495057);
            --monitor-progress-bg: var(--bs-gray-200, #e9ecef);
            --monitor-progress-bar: linear-gradient(90deg, var(--bs-primary, #44a2d2) 0%, #2d7ba8 100%);
            --monitor-stat-bg: var(--bs-gray-100, #f8f9fa);
            --monitor-stat-border: var(--bs-border-color, #dee2e6);
            --monitor-stat-active: var(--bs-primary, #44a2d2);
            --monitor-stage-bg: rgba(68, 162, 210, 0.1);
            --monitor-stage-text: var(--bs-primary, #44a2d2);
            
            /* Melhorias de Design System - mantidas para consistência */
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.04);
            --shadow-md: 0 2px 8px rgba(0, 0, 0, 0.08);
            --shadow-lg: 0 4px 16px rgba(0, 0, 0, 0.12);
            --shadow-xl: 0 8px 24px rgba(0, 0, 0, 0.16);
            --radius-sm: var(--bs-border-radius-sm, 0.25rem);
            --radius-md: var(--bs-border-radius, 0.375rem);
            --radius-lg: var(--bs-border-radius-lg, 0.5rem);
            --radius-xl: 0.75rem;
            --transition-fast: 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-base: 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --spacing-xl: 2rem;
        }

        /* Reset básico - Bootstrap já aplica box-sizing: border-box globalmente */
        /* Removido para evitar duplicação - Bootstrap já cuida disso */

        /* Body - Herda estilos de app.css/Bootstrap, apenas customizações específicas */
        body {
            /* Usa variáveis do Bootstrap para herança automática */
            font-family: var(--bs-font-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", "Noto Sans", "Liberation Sans", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji");
            background-color: var(--bs-body-bg, #f8f9fa);
            font-size: var(--bs-font-size-base, 0.93rem);
            line-height: var(--bs-body-line-height, 1.5);
            color: var(--bs-body-color, #212529);
            /* Customizações específicas da pasta digital */
            height: 100vh;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Acessibilidade - Skip Link */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--primary-blue);
            color: white;
            padding: 8px 16px;
            text-decoration: none;
            z-index: 1000;
        }
        
        .skip-link:focus {
            top: 0;
        }

        /* --- Header Modernizado --- 
           NOTA: Estilos específicos do header da pasta digital.
           Herda classes Bootstrap (.btn, .d-flex, etc.) de app.css */
        .app-header {
            height: var(--header-height);
            background: #ffffff;
            border-bottom: 1px solid var(--bs-border-color, #dee2e6);
            display: flex;
            align-items: center;
            padding: 0 1.5rem;
            z-index: 1030;
            position: sticky;
            top: 0;
            box-shadow: var(--shadow-sm);
            backdrop-filter: blur(10px);
            background-color: rgba(255, 255, 255, 0.95);
        }

        .app-header h1 {
            color: var(--bs-body-color, #212529);
            font-size: 1.125rem;
            font-weight: 600;
            letter-spacing: -0.01em;
            margin: 0;
            line-height: 1.4;
        }

        .app-header .mdi-folder-open {
            color: var(--bs-primary, #44a2d2);
            opacity: 0.9;
            transition: opacity var(--transition-fast);
        }

        .app-header .mdi-folder-open:hover {
            opacity: 1;
        }

        .materia-badge {
            background: linear-gradient(135deg, rgba(68, 162, 210, 0.1) 0%, rgba(68, 162, 210, 0.15) 100%);
            color: var(--bs-primary, #44a2d2);
            padding: 6px 16px;
            border-radius: var(--radius-xl);
            font-weight: 600;
            font-size: 0.8125rem;
            box-shadow: var(--shadow-sm);
            border: 1px solid rgba(68, 162, 210, 0.15);
            letter-spacing: -0.01em;
            transition: all var(--transition-fast);
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .materia-badge:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-1px);
        }

        /* Botões do Header - Herda estilos base de app.css, apenas customizações específicas */
        .app-header .btn {
            /* Usa font-size do sistema via variável */
            font-size: var(--bs-btn-font-size, 13px);
            /* Mantém apenas customizações específicas do header */
            padding: 8px 16px;
            gap: 0.5rem;
        }

        .app-header .btn:focus-visible {
            outline: 2px solid var(--bs-primary, #44a2d2);
            outline-offset: 2px;
        }

        /* btn-light - Herda de Bootstrap, apenas ajustes de hover específicos */
        .app-header .btn-light:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-1px);
        }

        .app-header .btn-light:active {
            transform: translateY(0);
            box-shadow: var(--shadow-sm);
        }

        /* btn-primary - Customização específica com gradiente */
        .app-header .btn-primary {
            background: linear-gradient(135deg, var(--bs-primary, #44a2d2) 0%, #2d7ba8 100%);
            border-color: rgba(68, 162, 210, 0.2);
        }

        .app-header .btn-primary:hover {
            background: linear-gradient(135deg, #2d7ba8 0%, #1f5a7a 100%);
            box-shadow: var(--shadow-lg);
            transform: translateY(-1px);
        }

        .app-header .btn-primary:active {
            transform: translateY(0);
            box-shadow: var(--shadow-md);
        }

        /* --- Estrutura Principal --- */
        .app-wrapper {
            display: flex;
            height: calc(100vh - var(--header-height));
        }

        /* --- Sidebar Estilizada --- */
        .app-sidebar {
            width: var(--sidebar-width);
            background: #ffffff;
            border-right: 1px solid var(--bs-border-color, #dee2e6);
            display: flex;
            flex-direction: column;
            transition: all var(--transition-slow);
            overflow: hidden;
            box-shadow: var(--shadow-md);
        }
        
        .app-sidebar > .sidebar-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: var(--spacing-md) var(--spacing-sm);
            background: var(--bs-gray-50, #fafafa);
            scrollbar-width: thin;
            scrollbar-color: var(--bs-gray-300, #dee2e6) transparent;
        }
        
        .sidebar-content .section-title:first-child {
            margin-top: var(--spacing-sm);
        }

        .sidebar-content::-webkit-scrollbar {
            width: 8px;
        }

        .sidebar-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .sidebar-content::-webkit-scrollbar-thumb {
            background: var(--bs-gray-300, #dee2e6);
            border-radius: 4px;
            transition: background var(--transition-fast);
        }

        .sidebar-content::-webkit-scrollbar-thumb:hover {
            background: var(--bs-gray-400, #ced4da);
        }
        
        /* Rodapé da sidebar */
        .sidebar-footer {
            padding: var(--spacing-md) var(--spacing-md);
            border-top: 1px solid var(--bs-border-color, #dee2e6);
            background: #ffffff;
            margin-top: auto;
        }
        
        /* Overlay para mobile */
        .sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        
        .materia-codigo {
            font-size: 0.8125rem;
            color: var(--bs-gray-600, #6c757d);
            font-weight: 500;
            letter-spacing: 0.01em;
        }

        .section-title {
            font-size: 0.6875rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--bs-gray-600, #6c757d);
            margin: var(--spacing-xl) 0 var(--spacing-md) 0;
            font-weight: 600;
            padding-bottom: var(--spacing-sm);
            border-bottom: 2px solid var(--bs-border-color, #dee2e6);
        }

        /* --- Itens da Lista (UX focada em cliques) --- */
        .doc-item {
            border: none;
            border-radius: var(--radius-md);
            margin-bottom: 6px;
            padding: 10px 12px;
            transition: all var(--transition-base);
            cursor: pointer;
            display: flex;
            align-items: center;
            color: var(--bs-body-color, #212529);
            text-decoration: none;
            font-size: 0.875rem;
            background: #ffffff;
            box-shadow: var(--shadow-sm);
            border: 1px solid transparent;
            position: relative;
        }

        .doc-item:hover {
            background-color: var(--bs-gray-100, #f8f9fa);
            box-shadow: var(--shadow-md);
            border-color: var(--bs-border-color, #dee2e6);
            transform: translateY(-1px);
        }

        .doc-item:active {
            transform: translateY(0);
            box-shadow: var(--shadow-sm);
        }

        .doc-item.active {
            background: linear-gradient(135deg, rgba(68, 162, 210, 0.1) 0%, rgba(68, 162, 210, 0.15) 100%);
            color: var(--bs-primary, #44a2d2);
            font-weight: 600;
            box-shadow: var(--shadow-md), 0 0 0 1px rgba(68, 162, 210, 0.15);
            border-color: rgba(68, 162, 210, 0.25);
        }

        .doc-item:focus-visible {
            outline: 2px solid var(--primary-blue);
            outline-offset: 2px;
        }


        .doc-item i {
            margin-right: 10px;
            font-size: 1.1rem;
            opacity: 0.9;
            transition: opacity var(--transition-fast);
            flex-shrink: 0;
        }

        .doc-item:hover i,
        .doc-item.active i {
            opacity: 1;
        }
        
        /* Badge de quantidade de páginas no documento */
        .doc-item-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            min-width: 0;
            gap: 6px;
        }
        
        .doc-item-title {
            flex: 1;
            min-width: 0;
            word-wrap: break-word;
            word-break: break-word;
            line-height: 1.35;
            letter-spacing: -0.01em;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
        }
        
        .doc-item-badge {
            background-color: var(--bs-gray-200, #e9ecef);
            color: var(--bs-gray-800, #343a40);
            font-size: 0.7rem;
            font-weight: 600;
            padding: 3px 9px;
            border-radius: 10px;
            flex-shrink: 0;
            white-space: nowrap;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(0, 0, 0, 0.05);
            height: fit-content;
            line-height: 1.4;
        }
        
        .doc-item.active .doc-item-badge {
            background: linear-gradient(135deg, var(--bs-primary, #44a2d2) 0%, #2d7ba8 100%);
            color: #ffffff;
            box-shadow: 0 2px 4px rgba(68, 162, 210, 0.25);
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        /* Botão de download de documento */
        .doc-download-btn {
            margin-left: auto;
            padding: 4px 8px;
            background: transparent;
            border: none;
            color: var(--bs-gray-600, #6c757d);
            cursor: pointer;
            opacity: 0.3; /* Temporário: sempre visível para debug */
            visibility: visible; /* Temporário: sempre visível para debug */
            transition: opacity 0.2s ease, color 0.2s ease, visibility 0.2s ease, background 0.2s ease;
            border-radius: 0.25rem;
            flex-shrink: 0;
            display: inline-flex !important;
            align-items: center;
            justify-content: center;
            min-width: 28px;
            height: 28px;
            font-size: 16px;
            line-height: 1;
        }

        .doc-item:hover .doc-download-btn,
        .doc-item.active .doc-download-btn,
        .doc-item-content:hover .doc-download-btn {
            opacity: 1 !important;
            visibility: visible !important;
        }

        .doc-download-btn:hover {
            color: var(--bs-primary, #44a2d2);
            background: var(--bs-gray-100, #f8f9fa);
        }

        .doc-download-btn:active {
            color: var(--bs-primary-dark, #2d7ba8);
            background: var(--bs-gray-200, #e9ecef);
        }
        
        /* Container do documento com páginas */
        .doc-wrapper {
            margin-bottom: 4px;
        }
        
        /* Ícone de expansão/colapso - Usa variáveis para herança */
        .doc-expand-icon {
            margin-right: 8px;
            font-size: 1rem;
            transition: transform var(--transition-base);
            color: var(--bs-gray-600, #6c757d);
            flex-shrink: 0;
            opacity: 0.8;
        }

        .doc-item:hover .doc-expand-icon,
        .doc-item.active .doc-expand-icon {
            opacity: 1;
            color: var(--bs-primary, #44a2d2);
        }
        
        .doc-wrapper.expanded .doc-expand-icon {
            transform: rotate(90deg);
            color: var(--bs-primary, #44a2d2);
            opacity: 1;
        }
        
        /* Container de páginas (sub-itens) */
        .doc-pages {
            max-height: 0;
            overflow: hidden;
            padding-left: 30px;
            padding-top: 0;
            padding-bottom: 0;
            margin-top: 3px;
            transition: max-height 0.35s cubic-bezier(0.4, 0, 0.2, 1), 
                        padding-top 0.35s cubic-bezier(0.4, 0, 0.2, 1), 
                        padding-bottom 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            border-left: 2px solid var(--bs-border-color, #dee2e6);
            margin-left: 4px;
        }
        
        .doc-wrapper.expanded .doc-pages {
            max-height: 400px;
            padding-top: 2px;
            padding-bottom: 2px;
            overflow-y: auto;
            overflow-x: hidden;
            border-left-color: rgba(68, 162, 210, 0.3);
        }
        
        /* Estilização da barra de scroll para lista de páginas */
        .doc-pages::-webkit-scrollbar {
            width: 6px;
        }
        
        .doc-pages::-webkit-scrollbar-track {
            background: #f8f9fa;
            border-radius: 3px;
            margin: 4px 0;
        }
        
        .doc-pages::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
            transition: background 0.2s;
        }
        
        .doc-pages::-webkit-scrollbar-thumb:hover {
            background: #9aa0a6;
        }
        
        /* Item de página (sub-item) */
        .doc-page-item {
            display: flex;
            align-items: center;
            padding: 5px 10px 5px 12px;
            margin-bottom: 1px;
            margin-left: -2px;
            border-radius: 6px;
            color: var(--bs-gray-700, #495057);
            text-decoration: none;
            font-size: 0.8125rem;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            background: transparent;
            position: relative;
        }
        
        .doc-page-item:hover {
            background-color: var(--bs-gray-200, #e9ecef);
            color: var(--bs-primary, #44a2d2);
            padding-left: 14px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
        }
        
        .doc-page-item.active {
            background: linear-gradient(135deg, rgba(68, 162, 210, 0.1) 0%, rgba(68, 162, 210, 0.15) 100%);
            color: var(--bs-primary, #44a2d2);
            font-weight: 600;
            box-shadow: 0 1px 4px rgba(68, 162, 210, 0.2);
            padding-left: 14px;
        }

        
        .doc-page-item i {
            margin-right: 8px;
            font-size: 0.9rem;
            opacity: 0.75;
            transition: opacity var(--transition-fast);
            flex-shrink: 0;
        }

        .doc-page-item:hover i,
        .doc-page-item.active i {
            opacity: 1;
        }

        /* --- Área do Visualizador --- */
        .viewer-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #525659;
            position: relative;
            overflow: hidden;
            border-left: 2px solid var(--bs-border-color, #dee2e6);
        }

        /* --- Toolbar Customizada Padronizada ---
           NOTA: Estilos específicos da toolbar. 
           Herda classes Bootstrap (.btn, .form-control, .badge) de app.css */
        .viewer-toolbar {
            height: var(--toolbar-height);
            background: var(--toolbar-bg);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 var(--spacing-lg);
            color: var(--toolbar-text);
            box-shadow: var(--shadow-md);
            border-bottom: 1px solid var(--toolbar-border);
            gap: var(--spacing-md);
            flex-wrap: wrap;
            position: relative;
            min-height: var(--toolbar-height);
        }
        
        @media (min-width: 1200px) {
            .viewer-toolbar {
                flex-wrap: nowrap;
            }
        }
        
        /* Overlay sobre a toolbar quando monitor está ativo */
        .viewer-toolbar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(2px);
            z-index: 10;
            display: none;
            pointer-events: all;
            cursor: not-allowed;
        }
        
        .viewer-toolbar.monitor-active::after {
            display: block;
        }
        
        .viewer-toolbar.monitor-active {
            opacity: 0.7;
        }
        
        .viewer-toolbar.monitor-active .btn,
        .viewer-toolbar.monitor-active .form-control {
            pointer-events: none;
            opacity: 0.6;
        }

        /* Grupos de controles na toolbar */
        .toolbar-group {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .toolbar-group:not(:last-child)::after {
            content: '';
            width: 1px;
            height: 32px;
            background: var(--bs-border-color, #dee2e6);
            margin-left: var(--spacing-md);
            margin-right: var(--spacing-xs);
            opacity: 0.8;
        }

        /* Botões da toolbar - Herda estilos base de app.css/Bootstrap */
        .viewer-toolbar .btn {
            /* Apenas customizações específicas da toolbar */
            font-size: var(--bs-btn-font-size, 13px);
            padding: 8px 14px;
            min-height: 36px;
            white-space: nowrap;
        }

        .viewer-toolbar .btn:focus-visible {
            outline: 2px solid var(--bs-primary, #44a2d2);
            outline-offset: 2px;
        }

        /* btn-dark - Customização específica para toolbar */
        .viewer-toolbar .btn-dark {
            background-color: var(--toolbar-btn-bg);
            border-color: var(--toolbar-border);
            color: var(--toolbar-text);
        }

        .viewer-toolbar .btn-dark:hover:not(:disabled) {
            background-color: var(--toolbar-btn-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .viewer-toolbar .btn-dark:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: var(--shadow-sm);
        }

        .viewer-toolbar .btn-dark:disabled {
            opacity: 1;
            cursor: not-allowed;
            background-color: var(--bs-gray-200, #e9ecef);
            color: var(--bs-gray-600, #6c757d);
            border-color: var(--bs-gray-300, #dee2e6);
        }

        /* btn-primary - Customização com gradiente específica */
        .viewer-toolbar .btn-primary {
            background: linear-gradient(135deg, var(--bs-primary, #44a2d2) 0%, #2d7ba8 100%);
            border-color: rgba(68, 162, 210, 0.2);
        }

        .viewer-toolbar .btn-primary:hover:not(:disabled) {
            background: linear-gradient(135deg, #2d7ba8 0%, #1f5a7a 100%);
            box-shadow: var(--shadow-md);
            transform: translateY(-1px);
        }

        .viewer-toolbar .btn-primary:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: var(--shadow-sm);
        }

        /* Inputs da toolbar - Herda estilos base de Bootstrap, apenas customizações específicas */
        .viewer-toolbar .form-control {
            background-color: var(--toolbar-input-bg);
            border-color: var(--toolbar-border);
            color: var(--toolbar-text);
            padding: 6px 12px;
            font-size: 0.875rem;
        }

        .viewer-toolbar .form-control:hover {
            border-color: var(--bs-gray-400, #ced4da);
        }

        .viewer-toolbar .form-control:focus {
            border-color: var(--bs-primary, #44a2d2);
            box-shadow: 0 0 0 3px rgba(68, 162, 210, 0.1);
        }

        /* Badge da toolbar - Customização específica */
        .viewer-toolbar .badge {
            background: var(--toolbar-badge-bg);
            color: var(--toolbar-badge-text);
            padding: 6px 14px;
            font-size: 0.8125rem;
            border: 1px solid rgba(68, 162, 210, 0.15);
        }

        /* Separador de página - Usa variáveis para herança */
        .page-separator {
            color: var(--bs-gray-600, #6c757d);
            font-weight: 500;
            padding: 0 var(--spacing-xs);
        }

        /* Container de navegação de página */
        .page-nav-container {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            background: var(--toolbar-btn-bg);
            padding: 4px;
            border-radius: var(--radius-md);
            border: 1px solid var(--toolbar-border);
        }

        .page-nav-container input {
            background: var(--toolbar-input-bg);
            border: 1px solid var(--toolbar-border);
            text-align: center;
            font-weight: 600;
        }
        
        /* Indicador de atalho de teclado */
        .keyboard-hint {
            font-size: 0.6875rem;
            color: #70757a;
            font-weight: 500;
            margin-left: var(--spacing-xs);
            white-space: nowrap;
            opacity: 0.8;
        }
        
        /* Melhorar visibilidade do hint em botões */
        .btn .keyboard-hint {
            margin-left: var(--spacing-xs);
            font-size: 0.65rem;
        }
        
        @media (max-width: 768px) {
            .keyboard-hint {
                display: none;
            }
        }

        /* Container de informações do documento */
        .doc-info-container {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: 6px 14px;
            background: var(--toolbar-btn-bg);
            border-radius: var(--radius-md);
            border: 1px solid var(--toolbar-border);
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--toolbar-text);
        }

        /* Ícones na toolbar */
        .viewer-toolbar .btn i {
            font-size: 1.1rem;
            line-height: 1;
        }

        .viewer-toolbar .btn-sm i {
            font-size: 1rem;
        }

        .iframe-wrapper {
            flex: 1;
            width: 100%;
            border: none;
            background: #525659;
            display: flex;
            justify-content: center;
            overflow: auto;
            position: relative;
            min-height: 400px; /* Garante altura mínima para centralização */
        }

        #iframeViewer {
            width: 100%;
            height: 100%;
            background: #fff;
            box-shadow: var(--shadow-xl);
            border-radius: var(--radius-md);
            border: none;
            transition: box-shadow var(--transition-base);
        }

        /* Responsividade Mobile */
        @media (max-width: 576px) {
            .app-header {
                padding: 0 1rem;
            }
            
            .app-header h1 {
                font-size: 1rem;
            }
            
            .app-header .btn {
                padding: 6px 12px;
                font-size: 0.8125rem;
            }
            
            .app-header .btn span {
                display: none;
            }
            
            .materia-badge {
                font-size: 0.75rem;
                padding: 4px 12px;
            }
            
            .viewer-toolbar {
                height: auto;
                min-height: 56px;
                flex-wrap: wrap;
                padding: var(--spacing-sm);
                gap: var(--spacing-sm);
                justify-content: center;
            }
            
            .viewer-toolbar .btn {
                min-height: 44px;
                min-width: 44px;
                padding: 6px 10px;
                font-size: 0.8125rem;
            }
            
            .viewer-toolbar .btn span {
                display: none;
            }
            
            /* Grupo de navegação de páginas - mantém os botões na mesma linha */
            .toolbar-group:has(.page-nav-container) {
                flex: 1 1 100%;
                justify-content: center;
                display: flex;
                gap: 0.5rem;
                order: -1;
                margin-bottom: 0.5rem;
            }
            
            /* Outros grupos de toolbar */
            .toolbar-group {
                flex-wrap: wrap;
            }
            
            .toolbar-group:not(:has(.page-nav-container)) {
                flex: 1 1 auto;
                justify-content: center;
            }
            
            .toolbar-group:not(:last-child)::after {
                display: none;
            }
            
            .page-nav-container {
                flex: 0 1 auto;
                padding: 2px;
            }
            
            .page-nav-container input {
                width: 72px !important;
                font-size: 0.875rem;
                min-width: 72px;
                padding-left: 4px !important;
                padding-right: 4px !important;
            }
            
            .page-nav-container .keyboard-hint {
                display: none;
            }
            
            .doc-info-container {
                padding: 4px 10px;
                font-size: 0.8125rem;
            }
            
            .btn span:not(.sr-only):not(.keyboard-hint) {
                display: none;
            }
            
            body {
                font-size: 0.875rem;
            }
            
            .doc-item {
                font-size: 0.8125rem;
                padding: 8px 10px;
            }
            
            #iframeViewer {
                border-radius: 0;
            }
            
            .progress-card {
                padding: var(--spacing-lg);
                margin: var(--spacing-sm);
                max-width: 90%;
            }
            
            .progress-card h5 {
                font-size: 1.125rem;
            }
            
            .progress-card #monitor-status {
                font-size: 0.875rem;
            }
            
            .progress-card #progress-details .col-4 {
                padding: 0 2px;
            }
            
            .progress-card #progress-details .p-2 {
                padding: var(--spacing-xs);
            }
            
            .progress-card #progress-details small {
                font-size: 0.6875rem;
            }

            .progress-card #progress-details .fw-bold {
                font-size: 0.875rem;
            }

            .toast-container {
                bottom: 1rem !important;
                right: 1rem !important;
                left: 1rem !important;
            }

            .toast {
                min-width: auto !important;
                width: 100%;
            }
        }
        
        @media (max-width: 768px) {
            #iframeViewer {
                border-radius: 0;
            }
            
            .btn, .doc-item, .doc-page-item {
                min-height: 44px;
                min-width: 44px;
            }
            
            .btn-sm {
                padding: 10px 14px;
                min-height: 44px;
            }
        }
        
        @media (max-width: 992px) {
            .app-sidebar {
                position: fixed;
                left: 0;
                top: var(--header-height);
                height: calc(100vh - var(--header-height));
                width: min(85vw, 400px);
                min-width: 280px;
                z-index: 1000;
                transform: translateX(-100%);
                transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                box-shadow: var(--shadow-xl);
            }
            
            .app-sidebar.open {
                transform: translateX(0);
            }
            
            .sidebar-overlay {
                display: block;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 999;
                opacity: 0;
                visibility: hidden;
                transition: opacity 0.3s ease, visibility 0.3s ease;
            }
            
            .sidebar-overlay.active {
                opacity: 1;
                visibility: visible;
            }
            
            .viewer-container {
                margin-left: 0;
            }
            
            .app-header {
                padding: 0 var(--spacing-md);
            }

            .materia-badge {
                font-size: 0.75rem;
                padding: 5px 12px;
            }
        }

        /* --- Monitor de Progresso Padronizado ---
           NOTA: Componente específico da pasta digital.
           Usa variáveis CSS para herança de cores do sistema */
        .async-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--monitor-overlay-bg);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
            padding: var(--spacing-md);
        }

        .progress-card {
            width: 100%;
            max-width: 560px;
            padding: var(--spacing-xl);
            background: var(--monitor-card-bg);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-xl);
            border: 1px solid var(--monitor-card-border);
            animation: slideUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        /* Título do Monitor */
        .progress-card h5 {
            color: var(--monitor-title-color);
            font-weight: 600;
            font-size: 1.25rem;
            margin-bottom: var(--spacing-sm);
            letter-spacing: -0.01em;
        }

        /* Texto de status */
        .progress-card #monitor-status {
            color: var(--monitor-text-color);
            font-size: 0.9375rem;
            line-height: 1.5;
            margin-bottom: var(--spacing-lg);
        }

        /* Barra de progresso customizada */
        .custom-progress {
            height: 12px;
            border-radius: var(--radius-md);
            background-color: var(--monitor-progress-bg);
            overflow: hidden;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05);
            margin-bottom: var(--spacing-md);
        }

        .custom-progress .progress-bar {
            background: var(--monitor-progress-bar);
            transition: width var(--transition-base);
            border-radius: var(--radius-md);
            box-shadow: 0 1px 3px rgba(26, 115, 232, 0.3);
            position: relative;
            overflow: hidden;
        }

        .custom-progress .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.3),
                transparent
            );
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Texto de progresso */
        .progress-card #progress-text {
            color: var(--monitor-text-color);
            font-size: 0.875rem;
            font-weight: 500;
            margin-top: var(--spacing-sm);
        }
        
        /* Porcentagem numérica na barra de progresso */
        .progress-card .progress-percentage {
            display: inline-block;
            font-weight: 600;
            color: var(--primary-blue);
            margin-left: var(--spacing-sm);
        }

        /* Container de estatísticas */
        .progress-card #progress-details {
            margin-top: var(--spacing-lg);
            display: flex !important;
            flex-wrap: wrap;
        }

        .progress-card #progress-details .col-4 {
            padding: 0 var(--spacing-xs);
            flex: 0 0 33.333333%;
            max-width: 33.333333%;
        }

        .progress-card #progress-details .p-2 {
            background: var(--monitor-stat-bg);
            border: 1px solid var(--monitor-stat-border);
            border-radius: var(--radius-md);
            padding: var(--spacing-sm);
            transition: all var(--transition-fast);
        }

        .progress-card #progress-details .border-primary {
            border-color: var(--monitor-stat-active) !important;
            background: linear-gradient(135deg, #e8f0fe 0%, #d2e3fc 100%);
        }

        .progress-card #progress-details small {
            color: var(--monitor-text-color);
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .progress-card #progress-details .fw-bold {
            color: var(--dark-text);
            font-size: 0.9375rem;
        }

        .progress-card #progress-details .text-primary {
            color: var(--monitor-stat-active) !important;
        }

        /* Indicador de etapa */
        .progress-card #stage-indicator {
            background: var(--monitor-stage-bg);
            border: 1px solid rgba(68, 162, 210, 0.2);
            border-radius: var(--radius-md);
            color: var(--monitor-stage-text);
            margin-top: var(--spacing-md);
        }

        .progress-card #stage-indicator p {
            color: var(--monitor-stage-text);
            font-weight: 500;
            margin: 0;
        }

        /* Timeline de etapas */
        .progress-card #stages-timeline {
            margin-top: var(--spacing-md);
            border: 1px solid var(--monitor-card-border);
            border-radius: var(--radius-md);
            background: var(--monitor-card-bg);
        }

        .progress-card #stages-timeline .card-body {
            padding: var(--spacing-md);
        }

        .progress-card #stages-timeline .list-group-item {
            border: none;
            border-bottom: 1px solid var(--monitor-card-border);
            padding: var(--spacing-sm) 0;
            background: transparent;
        }

        .progress-card #stages-timeline .list-group-item:last-child {
            border-bottom: none;
        }

        .progress-card #stages-timeline .list-group-item.active {
            background: var(--monitor-stage-bg);
            color: var(--monitor-stage-text);
            font-weight: 600;
        }

        .progress-card #stages-timeline .list-group-item.completed {
            color: var(--success-color);
        }

        /* --- Toasts Customizados ---
           NOTA: Customização específica dos toasts.
           Bootstrap já tem .toast, aqui apenas ajustamos posicionamento e estilo visual */
        .toast-container {
            position: fixed !important;
            bottom: 2rem !important;
            right: 2rem !important;
            z-index: 99999 !important;
            display: flex !important;
            flex-direction: column !important;
            gap: 0.75rem !important;
            pointer-events: none !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        .toast-container > * {
            pointer-events: auto !important;
        }

        .toast {
            padding: 1rem 1.5rem !important;
            background: white !important;
            border-radius: 8px !important;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important;
            border-left: 4px solid !important;
            display: flex !important;
            align-items: center !important;
            gap: 1rem !important;
            min-width: 300px !important;
            visibility: visible !important;
            opacity: 1 !important;
            position: relative !important;
            z-index: 100000 !important;
        }

        .toast.success { border-left-color: var(--success-color); }
        .toast.error { border-left-color: var(--danger-color); }
        .toast.info { border-left-color: var(--info-color); }
        .toast.warning { border-left-color: var(--warning-color); }
        
        /* Estilos para elementos internos do Toast */
        .toast-icon {
            font-size: 1.5rem;
            font-weight: bold;
            line-height: 1;
            flex-shrink: 0;
        }
        
        .toast-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        
        .toast-title {
            font-weight: 600;
            font-size: 0.95rem;
            color: #212529;
        }
        
        .toast-message {
            font-size: 0.875rem;
            color: #6c757d;
        }
        
        .toast-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            line-height: 1;
            color: #6c757d;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: color 0.2s;
        }
        
        .toast-close:hover {
            color: #212529;
        }
        
        /* Breadcrumbs - Estilo profissional */
        .breadcrumbs {
            border-bottom: 1px solid #e9ecef;
            background-color: #f8f9fa;
        }
        
        .breadcrumb {
            margin-bottom: 0;
            padding: 0.75rem 0;
        }
        
        .breadcrumb-item a {
            color: #556ee6;
            text-decoration: none;
        }
        
        .breadcrumb-item a:hover {
            text-decoration: underline;
        }
        
        /* Estilos removidos - usando novo layout */
        
        /* Controles de Página - Usando Bootstrap */
        .page-input {
            width: 80px;
            text-align: center;
        }
        
        /* Lista de Documentos - Usando Bootstrap Cards */
        .documento-item {
            border-left: 4px solid var(--primary-color);
            transition: var(--transition);
            cursor: pointer;
        }
        
        .documento-item:hover {
            transform: translateX(4px);
            box-shadow: var(--shadow);
        }
        
        .documento-pages {
            white-space: nowrap;
        }
        
        /* Loading e Error States - Usando Bootstrap */
        
        /* Footer - Usando Bootstrap */
        
        /* Acessibilidade - .sr-only já existe no Bootstrap, não precisa redefinir */
        
        /* Melhorias de Acessibilidade */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            .doc-item {
                border-width: 2px;
            }

            .doc-item.active {
                border-width: 3px;
            }

            .btn {
                border-width: 2px;
            }
        }

        /* Dark mode support (preparação futura) */
        @media (prefers-color-scheme: dark) {
            /* Mantido para futuras implementações */
        }
        
        /* Print Styles */
        @media print {
            .app-sidebar,
            .viewer-toolbar,
            .app-header,
            .toast-container,
            .sidebar-overlay {
                display: none !important;
            }
            
            .viewer-container {
                box-shadow: none;
            }

            #iframeViewer {
                box-shadow: none;
                border-radius: 0;
            }

            body {
                background: white;
            }
        }

        /* Melhorias de foco para acessibilidade */
        *:focus-visible {
            outline: 2px solid var(--primary-blue);
            outline-offset: 2px;
            border-radius: var(--radius-sm);
        }

        /* Loading state melhorado */
        .spinner-border {
            width: 3rem;
            height: 3rem;
            border-width: 0.25em;
        }
    </style>
    
    <script>window.application = "/";</script>
</head>
<body>
    <a href="#main-content" class="skip-link">Pular para conteúdo principal</a>
    
    <header class="app-header justify-content-between" role="banner">
        <div class="d-flex align-items-center">
            <button class="btn btn-light d-lg-none me-2" onclick="toggleSidebar()" aria-label="Alternar menu" aria-expanded="false" aria-controls="sidebar">
                <i class="mdi mdi-menu"></i>
            </button>
            <i class="mdi mdi-folder-open text-primary me-2" style="font-size: 24px;" aria-hidden="true"></i>
            <h1 class="h5 mb-0 fw-bold text-dark">Pasta Digital</h1>
            <span class="ms-3 materia-badge" id="materia-titulo">Carregando...</span>
        </div>
        
        <div class="d-flex gap-2">
            <a href="#" id="btn-download" class="btn btn-primary btn-sm d-flex align-items-center" role="button" aria-label="Baixar PDF Integral completo" target="_blank" rel="noopener noreferrer" style="display:none !important;">
                <i class="mdi mdi-download me-1" aria-hidden="true"></i> 
                <span class="d-none d-sm-inline">Download da Pasta</span>
            </a>
        </div>
    </header>

    <div class="app-wrapper">
        <!-- Overlay para mobile -->
        <div class="sidebar-overlay" id="sidebar-overlay" onclick="toggleSidebar()" aria-hidden="true"></div>
        
        <aside class="app-sidebar" id="sidebar" role="complementary" aria-label="Navegação de documentos">
            <div class="sidebar-content">
                <div class="section-title">Navegação do Processo</div>
                <nav id="documentos-nav" aria-label="Lista de documentos"></nav>

                <div id="relacionadas-section" style="display:none">
                    <div class="section-title">Matérias Relacionadas</div>
                    <nav id="relacionadas-nav" aria-label="Matérias relacionadas"></nav>
                </div>
                
                <div id="documentos-adm-section" style="display:none">
                    <div class="section-title">Processos Vinculados</div>
                    <nav id="documentos-adm-nav" aria-label="Processos vinculados"></nav>
                </div>
                
                <div id="normas-section" style="display:none">
                    <div class="section-title">Norma Derivada</div>
                    <nav id="normas-nav" aria-label="Norma derivada"></nav>
                </div>
            </div>
            
            <div class="sidebar-footer">
                <div class="materia-codigo" id="materia-codigo"></div>
            </div>
        </aside>

        <main class="viewer-container" id="main-content" role="main">
            <section role="region" aria-label="Visualizador de documentos" class="position-relative" style="flex: 1; display: flex; flex-direction: column;">
            
            <div class="viewer-toolbar" id="viewer-controls" role="toolbar" aria-label="Controles de visualização" style="display:none">
                <!-- Grupo: Navegação de Páginas -->
                <div class="toolbar-group">
                    <button class="btn btn-dark btn-sm" onclick="prevPagina()" aria-label="Página anterior" title="Página anterior (tecla ← ou seta esquerda)">
                        <i class="mdi mdi-chevron-left"></i>
                        <span class="sr-only">Anterior</span>
                    </button>
                    
                    <div class="page-nav-container">
                        <label for="page-input" class="sr-only">Ir para página</label>
                        <input type="number" id="page-input" class="form-control form-control-sm text-center" style="width: 75px; min-width: 65px;" value="1" min="1" max="9999" aria-label="Número da página atual. Digite o número e pressione Enter para ir" aria-required="true" aria-invalid="false" aria-describedby="total-pages-label keyboard-hint-page page-error" placeholder="Página" onkeypress="handlePageKeyPress(event)" onchange="goToPage(this.value)">
                        <span id="page-error" class="sr-only" role="alert"></span>
                        <span class="page-separator" aria-hidden="true">/</span>
                        <span id="total-pages" class="fw-bold" style="min-width: 50px; text-align: center;" aria-label="Total de páginas">0</span>
                        <span id="total-pages-label" class="sr-only">páginas no total</span>
                        <span id="keyboard-hint-page" class="keyboard-hint" aria-label="Atalhos de teclado: ← → para navegar, Enter para ir">← →</span>
                    </div>

                    <button class="btn btn-dark btn-sm" onclick="nextPagina()" aria-label="Próxima página" title="Próxima página (tecla → ou seta direita)">
                        <i class="mdi mdi-chevron-right"></i>
                        <span class="sr-only">Próxima</span>
                    </button>
                </div>
                
                <!-- Grupo: Navegação de Documentos -->
                <div class="toolbar-group">
                    <button class="btn btn-dark btn-sm" id="btn-prev-doc" aria-label="Documento anterior" onclick="prevDocumento()" title="Documento anterior (atalho: Ctrl+← ou Ctrl+seta esquerda)" style="display: none;">
                        <i class="mdi mdi-chevron-left"></i>
                        <span>Doc Anterior</span>
                        <span class="keyboard-hint">Ctrl+←</span>
                    </button>
                    <span class="badge" id="document-info" role="status" aria-live="polite" style="display: none;" title="Informação do documento atual"></span>
                    <button class="btn btn-dark btn-sm" id="btn-next-doc" aria-label="Próximo documento" onclick="nextDocumento()" title="Próximo documento (atalho: Ctrl+→ ou Ctrl+seta direita)" style="display: none;">
                        <span>Próximo Doc</span>
                        <i class="mdi mdi-chevron-right"></i>
                        <span class="keyboard-hint">Ctrl+→</span>
                    </button>
                </div>
            </div>

            <div class="iframe-wrapper position-relative">
                <div id="async-monitor" class="async-overlay" style="display:none">
                    <div class="progress-card">
                        <h5>Gerando Pasta Digital</h5>
                        <p id="monitor-status" role="status" aria-live="polite">Por favor, aguarde enquanto compilamos todas as peças do processo...</p>
                        
                        <div class="progress custom-progress">
                            <div id="progress-bar" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Progresso da geração" style="width: 0%">
                                <span class="visually-hidden">0%</span>
                            </div>
                        </div>
                        <p id="progress-text" role="status" aria-live="polite">Aguardando início...<span class="progress-percentage" id="progress-percentage"></span></p>

                        <div class="row text-center g-2" id="progress-details" style="display: none;">
                            <div class="col-4">
                                <div class="p-2">
                                    <small class="d-block">Velocidade</small>
                                    <span class="fw-bold" id="progress-speed">-</span>
                                </div>
                            </div>
                            <div class="col-4">
                                <div class="p-2 border-primary">
                                    <small class="d-block">Tempo Restante</small>
                                    <span class="fw-bold text-primary" id="progress-eta">--:--</span>
                                </div>
                            </div>
                            <div class="col-4">
                                <div class="p-2">
                                    <small class="d-block">Tempo Decorrido</small>
                                    <span class="fw-bold" id="progress-elapsed">00:00</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="alert alert-info" id="stage-indicator" style="display: none;">
                            <p class="mb-0" id="stage-text"></p>
                        </div>
                        
                        <div class="card" id="stages-timeline" style="display: none;">
                            <div class="card-body">
                                <ul class="list-group list-group-flush" id="stages-list"></ul>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="loading-state" class="async-overlay" style="display: flex;" aria-busy="true" aria-live="polite" aria-label="Carregando documentos">
                    <div class="progress-card text-center">
                        <div class="spinner-border text-primary" role="status" style="width: 3rem; height: 3rem; border-width: 0.25em;">
                            <span class="visually-hidden">Carregando...</span>
                        </div>
                        <h5 class="mt-3 mb-2">Carregando Pasta Digital</h5>
                        <p class="text-muted mb-0">Aguarde enquanto carregamos os documentos...</p>
                    </div>
                </div>

                <div id="error-state" class="async-overlay" style="display:none" role="alert" aria-live="assertive">
                    <div class="progress-card text-center">
                        <i class="mdi mdi-alert-circle text-danger" style="font-size: 64px; opacity: 0.8;" aria-hidden="true"></i>
                        <h5 class="mt-3 mb-2" id="error-title">Ops! Algo deu errado</h5>
                        <p id="error-message" class="text-muted mb-4"></p>
                        <button class="btn btn-primary" onclick="location.reload()" style="padding: 10px 24px; font-weight: 500;">
                            <i class="mdi mdi-refresh me-2"></i> Tentar Novamente
                        </button>
                    </div>
                </div>

                <iframe id="iframeViewer" name="iframeViewer" src="about:blank" title="Visualizador de PDF" aria-label="Visualizador de PDF do processo legislativo"></iframe>
            </div>
            </section>
        </main>
    </div>
            
    
    <!-- Container de Notificações Toast -->
    <div class="toast-container" id="toast-container" role="status" aria-live="polite" aria-atomic="true"></div>
    
    <script>
        // Configuração global
        var CONFIG = {
            POLLING_INTERVAL: 500,
            MAX_RETRIES: 3,
            RETRY_DELAY: 500,
            TOAST_DEFAULT_DURATION: 5000,
            PRELOAD_ADJACENT_PAGES: true,
            CACHE_BUSTING_ENABLED: true,
            DEBUG_MODE: false, // Habilitado temporariamente para debug do ajuste de scroll
            SCROLL_NAVIGATION_ENABLED: false,  // Desabilitado para permitir rolagem normal do documento
            SCROLL_THRESHOLD: 0.98,  // 98% do scroll para mudar de página (muito restritivo - permite ler página inteira)
            SCROLL_THROTTLE: 600,    // 600ms entre mudanças de página (aumentado para evitar mudanças rápidas)
            SCROLL_EDGE_THRESHOLD: 10, // 10px da borda para considerar "no final" (muito restritivo)
            SCROLL_MIN_STOP_TIME: 300, // 300ms parado no final antes de navegar (permite ler)
            SCROLL_DEBUG: false,      // Habilita logs de debug
            
            // ⚠️ PROTEÇÕES CONTRA NAVEGAÇÃO ACIDENTAL (Valores Conservadores)
            MIN_PAGE_VIEW_PERCENT: 0.80,        // 80%: Mínimo que usuário DEVE visualizar antes de permitir navegação
            ABSOLUTE_BOTTOM_THRESHOLD: 0.99,    // 99%: Final absoluto necessário para navegar (muito restritivo)
            ABSOLUTE_TOP_THRESHOLD: 0.01,       // 1%: Topo absoluto para voltar página anterior
            MIN_STOP_TIME: 800,                 // ms: Tempo mínimo parado no final antes de navegar
            SCROLL_STOP_TIMEOUT: 500,           // ms: Tempo sem scroll antes de considerar "parado"
            MIN_PAGE_TIME: 2000,                // ms: Tempo mínimo na página antes de permitir navegação
            ADDITIONAL_CONFIRMATION_TIME: 300,  // ms: Tempo extra após todas validações antes de navegar
            
            // Triggers (Somente após proteções passarem)
            PRELOAD_TRIGGER: 0.95,              // 95%: Pré-carrega próxima página (apenas visualização silenciosa)
            NAVIGATE_TRIGGER: 0.99,             // 99%: Inicia validação para navegação (MUITO restritivo)
            TOP_NAVIGATE_TRIGGER: 0.01,         // 1%: Volta para anterior (apenas no topo absoluto)
            
            // Validações de Segurança
            REQUIRE_FULL_STOP: true,            // true: Requer parar completamente antes de navegar
            REQUIRE_MIN_VIEW_PERCENT: true,     // true: Requer visualizar mínimo da página
            REQUIRE_MIN_PAGE_TIME: true,        // true: Requer tempo mínimo na página
            CANCEL_ON_SCROLL_BACK: true,        // true: Cancela navegação se voltar a rolar
            CANCEL_ON_MOVE_AWAY: true,          // true: Cancela se sair do final/topo
            
            // Performance (OTIMIZADO para documentos grandes - milhares de páginas)
            PRELOAD_ONLY_ADJACENT: true,        // true: Pré-carrega APENAS anterior (se existir) e próxima (se existir)
            PRELOAD_PREV: true,                 // true: Pré-carrega página anterior (se currentPage > 1)
            PRELOAD_NEXT: true,                 // true: Pré-carrega próxima página (se currentPage < totalPages)
            CACHE_SIZE: 3,                      // 3: Cache mínimo (atual, anterior, próxima) - máximo necessário
            CLEANUP_OLD_CACHE: true,            // true: Remove páginas do cache quando não são mais adjacentes
            MAX_CACHE_SIZE: 3,                  // 3: Máximo absoluto - nunca manter mais que 3 páginas em cache
            
            // Debug (para desenvolvimento)
            DEBUG_VALIDATIONS: false,           // Logs de cada validação
            DEBUG_TIMING: false                 // Logs de tempos e timeouts
        };
        
        let APP_DATA = {
            cod_materia: null,
            portal_url: null,
            pasta: null,
            materia: null,
            portal_config: null,
            materias_relacionadas: null,
            documentos_administrativos: null,
            normas_juridicas: null
        };
        
        // Verificação IMEDIATA dos dados injetados para mostrar monitor se necessário
        // Botão de download já está com display:none por padrão no HTML
        
        // Isso evita mostrar o loading-state quando o processo precisa ser gerado
        // Executa o mais rápido possível, mesmo antes do DOM estar pronto
        (function checkInitialState() {
            try {
                // Garante que o botão está escondido (já está no HTML, mas força aqui também)
                try {
                    var downloadBtn = document.getElementById('btn-download');
                    if (downloadBtn) {
                        downloadBtn.style.setProperty('display', 'none', 'important');
                    }
                } catch (e) {
                    // Ignora se DOM não estiver pronto
                }
                
                // Verifica se APP_DATA foi injetado pelo servidor e tem pasta
                if (typeof APP_DATA !== 'undefined' && APP_DATA.pasta) {
                    var pasta = APP_DATA.pasta;
                    var hasDocuments = pasta.documentos && pasta.documentos.length > 0;
                    var isAsync = pasta.async === true;
                    var needsGeneration = !hasDocuments || isAsync;
                    
                    if (needsGeneration) {
                        console.log('[checkInitialState] Processo precisa ser gerado, preparando monitor');
                        
                        // Função para mostrar monitor - tenta imediatamente e também quando DOM estiver pronto
                        function showMonitorNow() {
                            try {
                                var loadingState = document.getElementById('loading-state');
                                var asyncMonitor = document.getElementById('async-monitor');
                                
                                if (loadingState) {
                                    loadingState.style.display = 'none';
                                }
                                
                                if (asyncMonitor) {
                                    asyncMonitor.style.display = 'flex';
                                    
                                    // Esconde botão de download quando monitor é mostrado
                                    try {
                                        var downloadBtn = document.getElementById('btn-download');
                                        if (downloadBtn) {
                                            downloadBtn.style.setProperty('display', 'none', 'important');
                                        }
                                    } catch (e) {
                                        // Ignora erros
                                    }
                                    
                                    var monitorStatus = document.getElementById('monitor-status');
                                    if (monitorStatus) {
                                        monitorStatus.textContent = pasta.status_text || pasta.status || 'Iniciando geração...';
                                    }
                                    var progressBar = document.getElementById('progress-bar');
                                    if (progressBar) {
                                        progressBar.style.width = '0%';
                                    }
                                }
                            } catch (e) {
                                console.warn('[showMonitorNow] Erro:', e);
                            }
                        }
                        
                        // Tenta executar imediatamente (pode falhar se DOM não estiver pronto)
                        try {
                            showMonitorNow();
                        } catch (e) {
                            // Ignora erro se DOM não estiver pronto
                        }
                        
                        // Também agenda para quando DOM estiver pronto (garantia)
                        if (document.readyState === 'loading') {
                            document.addEventListener('DOMContentLoaded', showMonitorNow, { once: true });
                        } else {
                            // DOM já está pronto, executa novamente para garantir
                            setTimeout(showMonitorNow, 0);
                        }
                    }
                }
            } catch (e) {
                console.warn('[checkInitialState] Erro ao verificar estado inicial:', e);
            }
        })();
        
        // Cache de links pré-carregados
        var preloadCache = {};
        var currentPage = 1;
        var totalPages = 0;
        var currentDocumentoIndex = -1;
        var documentosList = [];
        
        // Variáveis para cálculo de progresso
        var progressStartTime = null;
        var progressHistory = [];
        var lastProgressUpdate = null;
        
        // Cache de elementos DOM para performance
        var domCache = {
            btnPrevDoc: null,
            btnNextDoc: null,
            documentInfo: null,
            _initialized: false
        };
        
        // Inicializa cache de elementos DOM
        function initDOMCache() {
            if (domCache._initialized) return;
            domCache.btnPrevDoc = document.getElementById('btn-prev-doc');
            domCache.btnNextDoc = document.getElementById('btn-next-doc');
            domCache.documentInfo = document.getElementById('document-info');
            domCache._initialized = true;
        }
        
        // Função para anunciar mudanças para screen readers
        function announceToScreenReader(message) {
            var announcement = document.createElement('div');
            announcement.setAttribute('role', 'status');
            announcement.setAttribute('aria-live', 'polite');
            announcement.setAttribute('aria-atomic', 'true');
            announcement.className = 'sr-only';
            announcement.textContent = message;
            document.body.appendChild(announcement);
            setTimeout(function() {
                if (announcement.parentElement) {
                    announcement.remove();
                }
            }, 1000);
        }
        
        // Função melhorada para toggle sidebar
        function toggleSidebar() {
            console.log('[toggleSidebar] Função chamada');
            var sidebar = document.getElementById('sidebar');
            var overlay = document.getElementById('sidebar-overlay');
            var toggleBtn = document.querySelector('[aria-controls="sidebar"]');
            
            console.log('[toggleSidebar] Elementos:', {
                sidebar: sidebar,
                overlay: overlay,
                toggleBtn: toggleBtn
            });
            
            if (!sidebar) {
                console.error('[toggleSidebar] Sidebar não encontrado!');
                return;
            }
            
            var isOpen = sidebar.classList.contains('open');
            console.log('[toggleSidebar] Estado atual - isOpen:', isOpen);
            
            if (isOpen) {
                sidebar.classList.remove('open');
                if (overlay) {
                    overlay.classList.remove('active');
                }
                if (toggleBtn) {
                    toggleBtn.setAttribute('aria-expanded', 'false');
                }
                console.log('[toggleSidebar] Sidebar fechado');
            } else {
                sidebar.classList.add('open');
                if (overlay) {
                    overlay.classList.add('active');
                }
                if (toggleBtn) {
                    toggleBtn.setAttribute('aria-expanded', 'true');
                }
                console.log('[toggleSidebar] Sidebar aberto');
            }
        }
        
        // Fechar sidebar com ESC (adicionar após DOM estar pronto)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                document.addEventListener('keydown', function(e) {
                    if (e.key === 'Escape' || e.keyCode === 27) {
                        var sidebar = document.getElementById('sidebar');
                        if (sidebar && sidebar.classList.contains('open')) {
                            toggleSidebar();
                        }
                    }
                });
            });
        } else {
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' || e.keyCode === 27) {
                    var sidebar = document.getElementById('sidebar');
                    if (sidebar && sidebar.classList.contains('open')) {
                        toggleSidebar();
                    }
                }
            });
        }
        
        // Função para mostrar notificação Toast
        function showToast(type, title, message, duration) {
            try {
                duration = duration || CONFIG.TOAST_DEFAULT_DURATION;
                var container = document.getElementById('toast-container');
                if (!container) {
                    console.error('[showToast] Container não encontrado!');
                    return;
                }
                // Toast sendo exibido
                    
                    var icons = {
                        success: '✓',
                        error: '✕',
                        info: 'ℹ',
                        warning: '⚠'
                    };
                    
                    // Ícones mais distintos com Material Design Icons
                    var iconClasses = {
                        success: 'mdi mdi-check-circle',
                        error: 'mdi mdi-alert-circle',
                        info: 'mdi mdi-information',
                        warning: 'mdi mdi-alert'
                    };
                    
                    var toast = document.createElement('div');
                    toast.className = 'toast ' + type;
                    toast.setAttribute('role', 'alert');
                    toast.setAttribute('aria-live', 'polite');
                    toast.setAttribute('aria-atomic', 'true');
                    
                    var icon = icons[type] || icons.info;
                    var iconSpan = document.createElement('span');
                    iconSpan.className = 'toast-icon';
                    iconSpan.setAttribute('aria-hidden', 'true');
                    iconSpan.textContent = icon;
                    
                    var contentDiv = document.createElement('div');
                    contentDiv.className = 'toast-content';
                    
                    var titleDiv = document.createElement('div');
                    titleDiv.className = 'toast-title';
                    titleDiv.textContent = title;
                    
                    var messageDiv = document.createElement('div');
                    messageDiv.className = 'toast-message';
                    // Sanitiza HTML para segurança
                    messageDiv.textContent = message;
                    
                    contentDiv.appendChild(titleDiv);
                    contentDiv.appendChild(messageDiv);
                    
                    var closeBtn = document.createElement('button');
                    closeBtn.className = 'toast-close';
                    closeBtn.setAttribute('type', 'button');
                    closeBtn.setAttribute('aria-label', 'Fechar notificação');
                    closeBtn.textContent = '×';
                    closeBtn.onclick = function() {
                        removeToast(toast);
                    };
                    
                    toast.appendChild(iconSpan);
                    toast.appendChild(contentDiv);
                    toast.appendChild(closeBtn);
                    
                    // Adiciona ao container primeiro
                    container.appendChild(toast);
                    
                    // Força estilos inline para garantir visibilidade (usando setProperty com important)
                    toast.style.setProperty('display', 'flex', 'important');
                    toast.style.setProperty('opacity', '1', 'important');
                    toast.style.setProperty('visibility', 'visible', 'important');
                    toast.style.setProperty('position', 'relative', 'important');
                    toast.style.setProperty('z-index', '10000', 'important');
                    toast.style.setProperty('background-color', '#ffffff', 'important');
                    toast.style.setProperty('box-shadow', '0 4px 12px rgba(0,0,0,0.15)', 'important');
                    
                    // Força o container a ser visível (garante que não seja sobrescrito)
                    container.style.setProperty('visibility', 'visible', 'important');
                    container.style.setProperty('opacity', '1', 'important');
                    container.style.setProperty('display', 'flex', 'important');
                    container.style.setProperty('z-index', '99999', 'important');
                    
                    // Animação simples (opcional - comentado por enquanto para garantir visibilidade)
                    // toast.style.opacity = '0';
                    // toast.style.transform = 'translateX(100%)';
                    // setTimeout(function() {
                    //     toast.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                    //     toast.style.opacity = '1';
                    //     toast.style.transform = 'translateX(0)';
                    // }, 10);
                    
                    // Remove após duração especificada
                    var timeoutId = setTimeout(function() {
                        removeToast(toast);
                    }, duration);
                    
                    // Salva timeoutId no toast para poder cancelar se necessário
                    toast._timeoutId = timeoutId;
                    
                } catch (error) {
                    console.error('[showToast] Erro ao exibir toast:', error);
                }
            }
            
            /**
             * Remove toast com animação
             * @private
             */
            function removeToast(toast) {
                if (!toast || !toast.parentElement) return;
                
                if (toast._timeoutId) {
                    clearTimeout(toast._timeoutId);
                }
                
                toast.style.transition = 'all 0.3s ease';
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(100%)';
                
                setTimeout(function() {
                    if (toast.parentElement) {
                        toast.remove();
                    }
                }, 300);
            }
        
            // ============================================
            // MÓDULO DE UTILITÁRIOS DE TEMPO
            // ============================================
            
            /**
             * Calcula estimativa de tempo restante (ETA)
             * @param {number} current - Valor atual
             * @param {number} total - Valor total
             * @param {number} startTime - Timestamp de início
             * @returns {number|null} ETA em segundos ou null
             */
            function calculateETA(current, total, startTime) {
                if (!startTime || current === 0 || current >= total) {
                    return null;
                }
                
                var elapsed = (Date.now() - startTime) / 1000;
                var rate = current / elapsed;
                var remaining = total - current;
                var etaSeconds = remaining / rate;
                
                return etaSeconds;
            }
            
            /**
             * Formata tempo em formato legível
             * @param {number} seconds - Segundos
             * @returns {string} Tempo formatado
             */
            function formatTime(seconds) {
                if (seconds === null || isNaN(seconds) || seconds < 0) {
                    return '-';
                }
                
                if (seconds < 60) {
                    return Math.round(seconds) + 's';
                } else if (seconds < 3600) {
                    var mins = Math.floor(seconds / 60);
                    var secs = Math.round(seconds % 60);
                    return mins + 'm ' + secs + 's';
                } else {
                    var hours = Math.floor(seconds / 3600);
                    var mins = Math.floor((seconds % 3600) / 60);
                    return hours + 'h ' + mins + 'm';
                }
            }
            
            /**
             * Formata tempo decorrido
             * @param {number} startTime - Timestamp de início
             * @returns {string} Tempo no formato MM:SS
             */
            function formatElapsedTime(startTime) {
                if (!startTime) return '00:00';
                
                var elapsed = (Date.now() - startTime) / 1000;
                var mins = Math.floor(elapsed / 60);
                var secs = Math.floor(elapsed % 60);
                return (mins < 10 ? '0' : '') + mins + ':' + (secs < 10 ? '0' : '') + secs;
            }
            
            /**
             * Calcula velocidade de processamento
             * @param {number} current - Valor atual
             * @param {number} startTime - Timestamp de início
             * @returns {string} Velocidade formatada
             */
            function calculateSpeed(current, startTime) {
                if (!startTime || current === 0) {
                    return '-';
                }
                
                var elapsed = (Date.now() - startTime) / 1000;
                var speed = current / elapsed;
                
                if (speed < 1) {
                    return (speed * 60).toFixed(1) + ' itens/min';
                } else {
                    return speed.toFixed(2) + ' itens/s';
                }
            }
        
        // Função para atualizar breadcrumbs
        function updateBreadcrumbs(materia) {
            var breadcrumbCurrent = document.getElementById('breadcrumb-current');
            var breadcrumbHome = document.getElementById('breadcrumb-home');
            
            if (breadcrumbCurrent && materia) {
                var titulo = materia.titulo || materia.sgl_tipo_materia + ' ' + 
                            materia.num_ident_basica + '/' + materia.ano_ident_basica;
                breadcrumbCurrent.textContent = titulo;
            }
            
            if (breadcrumbHome && APP_DATA.portal_url) {
                breadcrumbHome.href = APP_DATA.portal_url;
            }
        }
        
        // Função para navegar para documento anterior
        function prevDocumento() {
            try {
                if (currentDocumentoIndex <= 0) return;
                
                currentDocumentoIndex--;
                var documento = documentosList[currentDocumentoIndex];
                if (documento && documento.pagina_inicial) {
                    goToPage(documento.pagina_inicial);
                    updateDocumentNavigation();
                    showToast('info', 'Documento Anterior', documento.titulo || 'Documento ' + (currentDocumentoIndex + 1), 2000);
                }
            } catch (error) {
                console.error('[prevDocumento] Erro:', error);
                showToast('error', 'Erro', 'Não foi possível navegar para o documento anterior', 3000);
            }
        }
        
        // Função para navegar para próximo documento
        function nextDocumento() {
            try {
                if (currentDocumentoIndex >= documentosList.length - 1) return;
                
                currentDocumentoIndex++;
                var documento = documentosList[currentDocumentoIndex];
                if (documento && documento.pagina_inicial) {
                    goToPage(documento.pagina_inicial);
                    updateDocumentNavigation();
                    showToast('info', 'Próximo Documento', documento.titulo || 'Documento ' + (currentDocumentoIndex + 1), 2000);
                }
            } catch (error) {
                console.error('[nextDocumento] Erro:', error);
                showToast('error', 'Erro', 'Não foi possível navegar para o próximo documento', 3000);
            }
        }
        
        // Cache de elementos DOM para performance
        var domCache = {
            btnPrevDoc: null,
            btnNextDoc: null,
            documentInfo: null,
            _initialized: false
        };
        
        // Inicializa cache de elementos DOM
        function initDOMCache() {
            if (domCache._initialized) return;
            domCache.btnPrevDoc = document.getElementById('btn-prev-doc');
            domCache.btnNextDoc = document.getElementById('btn-next-doc');
            domCache.documentInfo = document.getElementById('document-info');
            domCache._initialized = true;
        }
        
        /**
         * Faz scroll automático para o item ativo na sidebar
         */
        function scrollToActiveDocument() {
            try {
                // Tenta primeiro encontrar página ativa, senão documento ativo
                var activeItem = document.querySelector('.doc-page-item.active') || document.querySelector('.doc-item.active');
                if (activeItem) {
                    activeItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            } catch (error) {
                console.warn('[scrollToActiveDocument] Erro ao fazer scroll:', error);
            }
        }
        
        // Função auxiliar global para colapsar todos os documentos exceto um específico
        function collapseAllDocumentsExcept(targetWrapper) {
            var allWrappers = document.querySelectorAll('.doc-wrapper');
            for (var i = 0; i < allWrappers.length; i++) {
                if (allWrappers[i] !== targetWrapper) {
                    allWrappers[i].classList.remove('expanded');
                }
            }
        }
        
        // Função para atualizar navegação de documentos (otimizada com cache)
        function updateDocumentNavigation() {
            try {
                initDOMCache();
                
                if (documentosList.length > 1) {
                    var canGoPrev = currentDocumentoIndex > 0;
                    var canGoNext = currentDocumentoIndex < documentosList.length - 1;
                    
                    if (domCache.btnPrevDoc) {
                        domCache.btnPrevDoc.style.display = canGoPrev ? 'block' : 'none';
                        domCache.btnPrevDoc.disabled = !canGoPrev;
                        domCache.btnPrevDoc.setAttribute('aria-disabled', !canGoPrev);
                        domCache.btnPrevDoc.setAttribute('title', canGoPrev ? 'Documento anterior' : 'Primeiro documento');
                    }
                    
                    if (domCache.btnNextDoc) {
                        domCache.btnNextDoc.style.display = canGoNext ? 'block' : 'none';
                        domCache.btnNextDoc.disabled = !canGoNext;
                        domCache.btnNextDoc.setAttribute('aria-disabled', !canGoNext);
                        domCache.btnNextDoc.setAttribute('title', canGoNext ? 'Próximo documento' : 'Último documento');
                    }
                    
                    if (domCache.documentInfo && currentDocumentoIndex >= 0 && currentDocumentoIndex < documentosList.length) {
                        var doc = documentosList[currentDocumentoIndex];
                        var docNum = currentDocumentoIndex + 1;
                        var docTitle = doc.titulo ? doc.titulo.substring(0, 30) + (doc.titulo.length > 30 ? '...' : '') : '';
                        domCache.documentInfo.textContent = 'Doc ' + docNum + ' de ' + documentosList.length + (docTitle ? ': ' + docTitle : '');
                        domCache.documentInfo.style.display = 'block';
                        domCache.documentInfo.setAttribute('aria-label', 'Documento ' + docNum + ' de ' + documentosList.length + (docTitle ? ': ' + docTitle : ''));
                    }
                } else {
                    if (domCache.btnPrevDoc) {
                        domCache.btnPrevDoc.style.display = 'none';
                    }
                    if (domCache.btnNextDoc) {
                        domCache.btnNextDoc.style.display = 'none';
                    }
                    if (domCache.documentInfo) {
                        domCache.documentInfo.style.display = 'none';
                    }
                }
                
                // Scroll automático para item ativo na sidebar
                setTimeout(function() {
                    scrollToActiveDocument();
                }, 100);
            } catch (error) {
                console.error('[updateDocumentNavigation] Erro:', error);
            }
        }
        
        // Função para encontrar documento atual baseado na página
        function findCurrentDocumento(pageNum) {
            if (!documentosList || documentosList.length === 0) return -1;
            
            for (var i = 0; i < documentosList.length; i++) {
                var doc = documentosList[i];
                if (pageNum >= doc.pagina_inicial && pageNum <= doc.pagina_final) {
                    return i;
                }
            }
            return -1;
        }
        
        // Função para atualizar timeline de etapas
        function updateStagesTimeline(currentStage, allStages) {
            var timeline = document.getElementById('stages-timeline');
            var stagesList = document.getElementById('stages-list');
            
            if (!timeline || !stagesList) return;
            
            if (!allStages || allStages.length === 0) {
                timeline.style.display = 'none';
                return;
            }
            
            timeline.style.display = 'block';
            stagesList.innerHTML = '';
            
            var stageMessages = {
                'init': 'Inicializando',
                'dados_materia': 'Obtendo dados da matéria',
                'preparar_dirs': 'Preparando diretórios',
                'coletar_docs': 'Coletando documentos',
                'mesclar_docs': 'Mesclando documentos',
                'salvar_paginas': 'Salvando páginas individuais',
                'salvar_pdf': 'Salvando PDF final',
                'limpar_temp': 'Limpando arquivos temporários',
                'concluido': 'Finalizando',
                'formatar': 'Formatando resultado',
                'finalizar': 'Finalizando'
            };
            
            var currentIndex = allStages.indexOf(currentStage);
            
            allStages.forEach(function(stage, index) {
                var li = document.createElement('li');
                li.className = 'list-group-item d-flex align-items-center';
                
                var icon = document.createElement('span');
                icon.className = 'me-3';
                if (index < currentIndex) {
                    icon.className += ' text-success';
                    icon.innerHTML = '<i class="mdi mdi-check-circle"></i>';
                } else if (index === currentIndex) {
                    icon.className += ' text-primary';
                    icon.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>';
                } else {
                    icon.className += ' text-muted';
                    icon.innerHTML = '<i class="mdi mdi-circle-outline"></i>';
                }
                
                var label = document.createElement('span');
                label.className = 'flex-grow-1';
                if (index < currentIndex) {
                    label.className += ' text-decoration-line-through text-muted';
                } else if (index === currentIndex) {
                    label.className += ' fw-bold text-primary';
                }
                label.textContent = stageMessages[stage] || stage;
                
                li.appendChild(icon);
                li.appendChild(label);
                stagesList.appendChild(li);
            });
        }
        
        // Função para atualizar recursos estáticos do sistema
        function updateStaticResources(portal_url) {
            // CSS do Sistema - Atualiza apenas se não estiverem preenchidos
            // Os CSS já são preenchidos no servidor para evitar FOUC
            var cssBootstrap = document.getElementById('css-bootstrap');
            if (cssBootstrap && (!cssBootstrap.href || cssBootstrap.href === '')) {
                cssBootstrap.href = portal_url + '/assets/css/bootstrap.min.css';
            }
            
            var cssIcons = document.getElementById('css-icons');
            if (cssIcons && (!cssIcons.href || cssIcons.href === '')) {
                cssIcons.href = portal_url + '/assets/css/icons.min.css';
            }          
           
            var cssAll = document.getElementById('css-all');
            if (cssAll && (!cssAll.href || cssAll.href === '')) {
                cssAll.href = portal_url + '/css/all.min.css';
            }
            
            var cssApp = document.getElementById('css-app');
            if (cssApp && (!cssApp.href || cssApp.href === '')) {
                cssApp.href = portal_url + '/assets/css/app.css';
            }
            
            // Atualiza favicon apenas se não estiver preenchido
            // O favicon já é preenchido no servidor
            var favicon = document.getElementById('favicon');
            if (favicon && (!favicon.href || favicon.href === '')) {
                favicon.href = portal_url + '/imagens/favicon.ico';
            }
            
            // Carrega JavaScript do sistema
            loadSystemScripts(portal_url);
        }
        
        // Função para carregar scripts do sistema
        function loadSystemScripts(portal_url) {
            // Verifica se os scripts já foram carregados
            if (window.systemScriptsLoaded) {
                return;
            }
            
            // jQuery
            if (!window.jQuery) {
                var jqueryScript = document.createElement('script');
                jqueryScript.src = portal_url + '/assets/libs/jquery/jquery.min.js';
                jqueryScript.onload = function() {
                    loadBootstrapScripts(portal_url);
                };
                document.head.appendChild(jqueryScript);
            } else {
                loadBootstrapScripts(portal_url);
            }
        }
        
        // Função para carregar scripts do Bootstrap e outros na ordem correta
        function loadBootstrapScripts(portal_url) {
            // Scripts na ordem de dependência
            var scripts = [
                portal_url + '/assets/libs/bootstrap/js/bootstrap.bundle.min.js',
                portal_url + '/assets/libs/metismenu/metisMenu.min.js',
                portal_url + '/assets/libs/simplebar/simplebar.min.js',
                portal_url + '/assets/libs/node-waves/waves.min.js',
                portal_url + '/assets/js/app.js',
                portal_url + '/js/geral.js'
            ];
            
            // Carrega scripts sequencialmente para garantir ordem
            function loadScript(index) {
                if (index >= scripts.length) {
                    window.systemScriptsLoaded = true;
                    return;
                }
                
                var script = document.createElement('script');
                script.src = scripts[index];
                script.onload = function() {
                    // Carrega próximo script após este carregar
                    loadScript(index + 1);
                };
                script.onerror = function() {
                    console.warn('Erro ao carregar script:', scripts[index]);
                    // Continua mesmo se houver erro
                    loadScript(index + 1);
                };
                document.head.appendChild(script);
            }
            
            // Inicia carregamento
            loadScript(0);
        }
        
        // Função para pré-carregar páginas adjacentes
        // Função antiga mantida para compatibilidade - será substituída pela nova implementação otimizada
        function preloadAdjacentPages_OLD(currentPage) {
            var currentPageNum = parseInt(currentPage);
            if (isNaN(currentPageNum)) return;
            
            var prevPage = currentPageNum - 1;
            var nextPage = currentPageNum + 1;
            
            [prevPage, nextPage].forEach(function(pageNum) {
                if (pageNum < 1 || pageNum > totalPages) return;
                var linkEl = document.querySelector('a[data-pagina-geral="' + pageNum + '"]');
                if (linkEl && !preloadCache[pageNum]) {
                    var link = linkEl.getAttribute('href');
                    if (link) {
                        var linkTag = document.createElement('link');
                        linkTag.rel = 'prefetch';
                        linkTag.href = link;
                        document.head.appendChild(linkTag);
                        preloadCache[pageNum] = true;
                    }
                }
            });
        }
        
        // Variável global para rastrear direção da navegação (para ajustar scroll após carregamento)
        var lastNavigationDirection = null; // 'up' ou 'down' ou null
        
        function prevPagina() {
            if (currentPage > 1) {
                lastNavigationDirection = 'up'; // Navegação para cima = abrir no final
                goToPage(currentPage - 1);
            } else {
                if (typeof announceToScreenReader === 'function') {
                    announceToScreenReader('Já está na primeira página');
                }
            }
        }
        
        function nextPagina() {
            if (currentPage < totalPages) {
                lastNavigationDirection = 'down'; // Navegação para baixo = abrir no topo
                goToPage(currentPage + 1);
            } else {
                if (typeof announceToScreenReader === 'function') {
                    announceToScreenReader('Já está na última página');
                }
            }
        }
        
        function handlePageKeyPress(event) {
            if (event.key === 'Enter' || event.keyCode === 13) {
                event.preventDefault();
                var pagina = parseInt(event.target.value);
                goToPage(pagina);
            }
        }
        
        // ============================================
        // NAVEGAÇÃO POR SCROLL DO MOUSE
        // ============================================
        
        var scrollNavigationThrottle = null;
        var lastScrollTime = 0;
        var scrollNavigationEnabled = CONFIG.SCROLL_NAVIGATION_ENABLED;
        var scrollDirection = null; // 'up' ou 'down'
        var scrollDirectionCount = 0; // Contador de scrolls na mesma direção
        var scrollDirectionTimeout = null; // Timeout para resetar direção
        var lastScrollPosition = null; // Última posição do scroll
        var scrollStopTimer = null; // Timer para detectar quando parou de rolar
        var pendingNavigation = null; // Navegação pendente (aguardando confirmação)
        
        // ============================================
        // RASTREAMENTO DE VISUALIZAÇÃO COMPLETA
        // ============================================
        var pageViewTracker = {
            pageStartTime: null,           // Timestamp quando entrou na página
            minScrollPosition: Infinity,   // Menor posição de scroll alcançada
            maxScrollPosition: 0,          // Maior posição de scroll alcançada
            scrollPath: [],                // Array de posições visitadas (para calcular % visualizado)
            lastScrollTime: null,          // Último momento de scroll
            scrollStopTimer: null,         // Timer para detectar parada
            navigationPendingTimer: null,  // Timer para navegação pendente (próxima página)
            navigationPendingTimerTop: null, // Timer para navegação pendente (página anterior)
            hasReachedBottom: false,       // Se chegou ao final da página
            hasReachedTop: false,          // Se chegou ao topo da página
            navigationCancelled: false,    // Se navegação foi cancelada
            navigationCancelledTop: false  // Se navegação para cima foi cancelada
        };
        
        // ============================================
        // CACHE DE PRÉ-CARREGAMENTO (OTIMIZADO)
        // ============================================
        var pageCache = {
            current: null,      // Página atual (carregada no iframe principal)
            previous: null,     // Página anterior (se existir)
            next: null,         // Próxima página (se existir)
            iframes: {}         // Objeto com iframes de cache: { pageNum: iframeElement }
        };
        
        /**
         * Verifica se o scroll chegou ao topo ou ao final da página
         * Tenta múltiplas abordagens para funcionar com PDF.js
         * @param {HTMLElement} element - Elemento a verificar
         * @param {Window} iframeWindow - Janela do iframe (opcional)
         * @returns {Object} {atTop: boolean, atBottom: boolean, scrollPercent: number}
         */
        function getScrollPosition(element, iframeWindow) {
            if (!element && !iframeWindow) {
                return { atTop: false, atBottom: false, scrollPercent: 0 };
            }
            
            var scrollTop = 0;
            var scrollHeight = 0;
            var clientHeight = 0;
            var edgeThreshold = CONFIG.SCROLL_EDGE_THRESHOLD || 50;
            
            // Tenta obter do elemento
            if (element) {
                scrollTop = element.scrollTop || 0;
                scrollHeight = element.scrollHeight || 0;
                clientHeight = element.clientHeight || 0;
            }
            
            // Tenta obter da janela do iframe (para PDF.js)
            if (iframeWindow) {
                try {
                    // Primeiro tenta acessar o iframe interno do PDF.js (onde o PDF realmente está renderizado)
                    var pdfjsIframe = null;
                    try {
                        var iframeDoc = iframeWindow.document;
                        if (iframeDoc) {
                            // PDF.js renderiza dentro de um iframe interno
                            pdfjsIframe = iframeDoc.querySelector('iframe#viewer') || 
                                         iframeDoc.querySelector('iframe.viewer') ||
                                         iframeDoc.querySelector('iframe');
                        }
                    } catch (e) {
                        // CORS - ignora
                    }
                    
                    // Se encontrou iframe interno, tenta obter scroll dele
                    if (pdfjsIframe && pdfjsIframe.contentWindow) {
                        try {
                            var innerWin = pdfjsIframe.contentWindow;
                            var innerScrollTop = innerWin.pageYOffset || innerWin.scrollY || 0;
                            var innerScrollHeight = innerWin.document.documentElement.scrollHeight || 
                                                   innerWin.document.body.scrollHeight || 0;
                            var innerClientHeight = innerWin.innerHeight || 
                                                  innerWin.document.documentElement.clientHeight || 0;
                            
                            if (innerScrollHeight > scrollHeight) {
                                scrollTop = innerScrollTop;
                                scrollHeight = innerScrollHeight;
                                clientHeight = innerClientHeight;
                            }
                        } catch (e) {
                            // CORS no iframe interno - continua com iframeWindow original
                        }
                    }
                    
                    // Tenta também via window.frames se disponível
                    if (iframeWindow.frames && iframeWindow.frames.length > 0) {
                        try {
                            var firstFrame = iframeWindow.frames[0];
                            if (firstFrame && firstFrame.document) {
                                var frameScrollTop = firstFrame.pageYOffset || firstFrame.scrollY || 0;
                                var frameScrollHeight = firstFrame.document.documentElement.scrollHeight || 
                                                       firstFrame.document.body.scrollHeight || 0;
                                var frameClientHeight = firstFrame.innerHeight || 
                                                      firstFrame.document.documentElement.clientHeight || 0;
                                
                                if (frameScrollHeight > scrollHeight) {
                                    scrollTop = frameScrollTop;
                                    scrollHeight = frameScrollHeight;
                                    clientHeight = frameClientHeight;
                                }
                            }
                        } catch (e) {
                            // CORS - ignora
                        }
                    }
                    
                    // Tenta obter do iframeWindow original
                    var winScrollTop = iframeWindow.pageYOffset || iframeWindow.scrollY || 0;
                    var winScrollHeight = iframeWindow.document.documentElement.scrollHeight || 
                                         iframeWindow.document.body.scrollHeight || 0;
                    var winClientHeight = iframeWindow.innerHeight || 
                                        iframeWindow.document.documentElement.clientHeight || 0;
                    
                    // Usa valores da janela se disponíveis e maiores
                    if (winScrollHeight > scrollHeight) {
                        scrollTop = winScrollTop;
                        scrollHeight = winScrollHeight;
                        clientHeight = winClientHeight;
                    }
                } catch (e) {
                    // CORS - ignora
                }
            }
            
            // Tenta obter do documentElement ou body
            if (element && element.documentElement) {
                var docEl = element.documentElement;
                var docScrollTop = docEl.scrollTop || 0;
                var docScrollHeight = docEl.scrollHeight || 0;
                var docClientHeight = docEl.clientHeight || 0;
                
                if (docScrollHeight > scrollHeight) {
                    scrollTop = docScrollTop;
                    scrollHeight = docScrollHeight;
                    clientHeight = docClientHeight;
                }
            }
            
            var maxScroll = scrollHeight - clientHeight;
            var scrollPercent = maxScroll > 0 ? scrollTop / maxScroll : 0;
            
            // Considera "no final" apenas se está muito próximo da borda (muito restritivo)
            // Permite visualizar e ler a página inteira antes de navegar
            // Requer: estar dentro de 10px do final E ter scrollPercent >= 98%
            var distanceFromBottom = maxScroll > 0 ? maxScroll - scrollTop : Infinity;
            var atBottom = maxScroll > 0 && 
                          distanceFromBottom <= edgeThreshold && 
                          scrollPercent >= CONFIG.SCROLL_THRESHOLD;
            // Mesma tolerância do bottom: dentro de edgeThreshold do topo
            // Permite visualizar o topo da página antes de navegar
            // Requer: estar dentro de 10px do topo E ter scrollPercent <= 2% (equivalente ao threshold do bottom)
            var topThreshold = 1 - CONFIG.SCROLL_THRESHOLD; // 2% (equivalente aos 98% do bottom)
            var atTop = scrollTop <= edgeThreshold && 
                       scrollPercent <= topThreshold;
            
            return {
                atTop: atTop,
                atBottom: atBottom,
                scrollPercent: scrollPercent,
                scrollTop: scrollTop,
                maxScroll: maxScroll,
                scrollHeight: scrollHeight,
                clientHeight: clientHeight
            };
        }
        
        /**
         * Handler para navegação por scroll do mouse
         * @param {WheelEvent} event - Evento de scroll
         */
        function handleScrollNavigation(event) {
            // Verifica se a funcionalidade está habilitada
            if (!scrollNavigationEnabled || !CONFIG.SCROLL_NAVIGATION_ENABLED) {
                return;
            }
            
            // Verifica se há páginas disponíveis
            if (!totalPages || totalPages <= 1) {
                return;
            }
            
            // Throttle: evita múltiplas chamadas rápidas
            var now = Date.now();
            if (now - lastScrollTime < CONFIG.SCROLL_THROTTLE) {
                return;
            }
            
            // Obtém o iframe e seu conteúdo
            var iframe = document.getElementById('iframeViewer');
            if (!iframe) {
                return;
            }
            
            // Verifica a direção do scroll
            var deltaY = event.deltaY || event.detail || 0;
            var isScrollingDown = deltaY > 0;
            var isScrollingUp = deltaY < 0;
            
            // Se não há movimento significativo, ignora
            if (Math.abs(deltaY) < 10) {
                return;
            }
            
            try {
                var iframeWindow = iframe.contentWindow;
                var iframeDoc = iframe.contentDocument || (iframeWindow ? iframeWindow.document : null);
                
                // Tenta obter posição do scroll de múltiplas formas
                var scrollPos = null;
                
                if (iframeDoc) {
                    // Tenta do documentElement
                    scrollPos = getScrollPosition(iframeDoc.documentElement, iframeWindow);
                    
                    // Se não obteve valores válidos, tenta do body
                    if (scrollPos.scrollHeight === 0 && iframeDoc.body) {
                        var bodyPos = getScrollPosition(iframeDoc.body, iframeWindow);
                        if (bodyPos.scrollHeight > 0) {
                            scrollPos = bodyPos;
                        }
                    }
                }
                
                // Se ainda não obteve, tenta apenas da janela
                if (!scrollPos || scrollPos.scrollHeight === 0) {
                    if (iframeWindow) {
                        try {
                            scrollPos = getScrollPosition(null, iframeWindow);
                        } catch (e) {
                            // CORS
                        }
                    }
                }
                
                // Se não conseguiu obter posição válida, usa detecção de scroll contínuo
                if (!scrollPos || scrollPos.scrollHeight === 0 || scrollPos.maxScroll <= 0) {
                    // Detecta scroll contínuo na mesma direção
                    var currentDirection = isScrollingDown ? 'down' : 'up';
                    
                    if (scrollDirection === currentDirection) {
                        scrollDirectionCount++;
                    } else {
                        scrollDirection = currentDirection;
                        scrollDirectionCount = 1;
                    }
                    
                    // Limpa timeout anterior
                    if (scrollDirectionTimeout) {
                        clearTimeout(scrollDirectionTimeout);
                    }
                    
                    // Reseta contador após 800ms sem scroll (aumentado para evitar navegação prematura)
                    scrollDirectionTimeout = setTimeout(function() {
                        scrollDirection = null;
                        scrollDirectionCount = 0;
                    }, 800);
                    
                    // Navega apenas se houver scroll contínuo muito significativo
                    // Para baixo: 8+ eventos (muito restritivo - permite ler página inteira)
                    // Para cima: 3+ eventos (mais restritivo, para evitar navegação acidental)
                    var requiredCount = isScrollingDown ? 8 : 3;
                    
                    if (scrollDirectionCount >= requiredCount) {
                        if (isScrollingDown && currentPage < totalPages) {
                            lastScrollTime = now;
                            scrollDirectionCount = 0; // Reset contador
                            event.preventDefault();
                            event.stopPropagation();
                            nextPagina();
                            return;
                        } else if (isScrollingUp && currentPage > 1) {
                            lastScrollTime = now;
                            scrollDirectionCount = 0; // Reset contador
                            event.preventDefault();
                            event.stopPropagation();
                            prevPagina();
                            return;
                        }
                    }
                    return;
                }
                
                // Se conseguiu obter posição mas o scroll é muito pequeno (PDF de 1 página)
                // Usa detecção de scroll contínuo como fallback adicional
                if (scrollPos.maxScroll <= 100 && scrollPos.scrollHeight > 0) {
                    var currentDirection = isScrollingDown ? 'down' : 'up';
                    
                    if (scrollDirection === currentDirection) {
                        scrollDirectionCount++;
                    } else {
                        scrollDirection = currentDirection;
                        scrollDirectionCount = 1;
                    }
                    
                    if (scrollDirectionTimeout) {
                        clearTimeout(scrollDirectionTimeout);
                    }
                    
                    scrollDirectionTimeout = setTimeout(function() {
                        scrollDirection = null;
                        scrollDirectionCount = 0;
                    }, 800);
                    
                    // Para PDFs pequenos, ainda requer scroll contínuo muito significativo
                    // Para baixo: 8+ eventos (permite ler página inteira)
                    // Para cima: 3+ eventos
                    var requiredCount = isScrollingDown ? 8 : 3;
                    
                    // IMPORTANTE: Comportamento antigo (sem validações rigorosas) só se proteções estão desabilitadas
                    // Se proteções estão habilitadas, validações já foram aplicadas acima e retornaram
                    if (scrollDirectionCount >= requiredCount) {
                        // Navegação para baixo - só se proteções não estão habilitadas
                        if (isScrollingDown && currentPage < totalPages &&
                            (!CONFIG.SCROLL_NAVIGATION_ENABLED || !scrollNavigationEnabled ||
                             (!CONFIG.REQUIRE_MIN_VIEW_PERCENT && !CONFIG.REQUIRE_MIN_PAGE_TIME))) {
                            lastScrollTime = now;
                            scrollDirectionCount = 0;
                            event.preventDefault();
                            event.stopPropagation();
                            nextPagina();
                            return;
                        }
                        // Navegação para cima - só se proteções não estão habilitadas
                        // Se proteções estão habilitadas, a lógica acima já tratou isso
                        else if (isScrollingUp && scrollPos.atTop && currentPage > 1 &&
                                (!CONFIG.SCROLL_NAVIGATION_ENABLED || !scrollNavigationEnabled ||
                                 (!CONFIG.REQUIRE_MIN_VIEW_PERCENT && !CONFIG.REQUIRE_MIN_PAGE_TIME))) {
                            // Para cima sem validações: só navega se realmente está no topo
                            // Aplica validação básica de estar no topo (5%)
                            if (scrollPos.scrollPercent <= 0.05) {
                                lastScrollTime = now;
                                scrollDirectionCount = 0;
                                event.preventDefault();
                                event.stopPropagation();
                                prevPagina();
                                return;
                            }
                        }
                    }
                }
                
                // Navega para próxima página APENAS se realmente chegou ao final E parou de rolar
                // Permite visualizar e ler a página inteira antes de navegar
                if (isScrollingDown && currentPage < totalPages) {
                    var distanceFromBottom = scrollPos.maxScroll - scrollPos.scrollTop;
                    var isAtBottom = scrollPos.atBottom;
                    
                    // ⚠️ VALIDAÇÕES DE PROTEÇÃO (se habilitadas E scroll navigation está habilitado)
                    // IMPORTANTE: Validações só são aplicadas se scroll navigation estiver habilitado
                    if (CONFIG.SCROLL_NAVIGATION_ENABLED && scrollNavigationEnabled && 
                        (CONFIG.REQUIRE_MIN_VIEW_PERCENT || CONFIG.REQUIRE_MIN_PAGE_TIME)) {
                        
                        // Valida se chegou ao final absoluto (99%+)
                        var isAtAbsoluteBottom = scrollPos.scrollPercent >= CONFIG.ABSOLUTE_BOTTOM_THRESHOLD;
                        
                        // Se não está no final absoluto, não navega
                        if (!isAtAbsoluteBottom) {
                            // Atualiza último tempo de scroll para rastreamento
                            if (pageViewTracker && typeof pageViewTracker === 'object') {
                                pageViewTracker.lastScrollTime = Date.now();
                            }
                            return; // Permite scroll normal dentro da página
                        }
                        
                        // Valida visualização mínima (80%)
                        if (CONFIG.REQUIRE_MIN_VIEW_PERCENT && typeof getPageViewPercent === 'function') {
                            var viewPercent = getPageViewPercent();
                            if (viewPercent < CONFIG.MIN_PAGE_VIEW_PERCENT) {
                                if (CONFIG.DEBUG_MODE || CONFIG.SCROLL_DEBUG) {
                                    console.log('[handleScrollNavigation] Bloqueado: Visualizou apenas', Math.round(viewPercent * 100) + '% da página (mínimo: ' + Math.round(CONFIG.MIN_PAGE_VIEW_PERCENT * 100) + '%)');
                                }
                                if (pageViewTracker && typeof pageViewTracker === 'object') {
                                    pageViewTracker.lastScrollTime = Date.now();
                                }
                                return; // Não visualizou suficiente, bloqueia navegação
                            }
                        }
                        
                        // Valida tempo mínimo na página (2s)
                        if (CONFIG.REQUIRE_MIN_PAGE_TIME && pageViewTracker && typeof pageViewTracker === 'object' && pageViewTracker.pageStartTime) {
                            var timeOnPage = Date.now() - pageViewTracker.pageStartTime;
                            if (timeOnPage < CONFIG.MIN_PAGE_TIME) {
                                if (CONFIG.DEBUG_MODE || CONFIG.SCROLL_DEBUG) {
                                    console.log('[handleScrollNavigation] Bloqueado: Tempo na página insuficiente (' + Math.round(timeOnPage / 1000) + 's, mínimo: ' + CONFIG.MIN_PAGE_TIME / 1000 + 's)');
                                }
                                if (pageViewTracker && typeof pageViewTracker === 'object') {
                                    pageViewTracker.lastScrollTime = Date.now();
                                }
                                return; // Tempo insuficiente, bloqueia navegação
                            }
                        }
                        
                        // Se passou nas validações, usa startNavigationProcess para navegação controlada
                        // Mas apenas se ainda não iniciou o processo
                        if (pageViewTracker && typeof pageViewTracker === 'object' && 
                            (!pageViewTracker.hasReachedBottom || !pageViewTracker.navigationPendingTimer)) {
                            // Chama onReachedBottom que vai usar todas as validações
                            if (typeof onReachedBottom === 'function') {
                                onReachedBottom(scrollPos);
                            }
                        }
                        return; // Retorna, a navegação será feita pelo startNavigationProcess
                    }
                    
                    // ⚠️ VALIDAÇÕES DE PROTEÇÃO PARA ROLAGEM PARA CIMA (página anterior)
                    // IMPORTANTE: Validações só são aplicadas se scroll navigation estiver habilitado
                    if (CONFIG.SCROLL_NAVIGATION_ENABLED && scrollNavigationEnabled && 
                        (CONFIG.REQUIRE_MIN_VIEW_PERCENT || CONFIG.REQUIRE_MIN_PAGE_TIME) &&
                        isScrollingUp && currentPage > 1) {
                        
                        // Valida se chegou ao topo absoluto (1% ou menos)
                        var isAtAbsoluteTop = scrollPos.scrollPercent <= CONFIG.ABSOLUTE_TOP_THRESHOLD;
                        
                        // Se não está no topo absoluto, não navega
                        if (!isAtAbsoluteTop) {
                            // Atualiza último tempo de scroll para rastreamento
                            if (pageViewTracker && typeof pageViewTracker === 'object') {
                                pageViewTracker.lastScrollTime = Date.now();
                            }
                            return; // Permite scroll normal dentro da página
                        }
                        
                        // Valida visualização mínima (80%) - usuário precisa ter visualizado a página atual
                        if (CONFIG.REQUIRE_MIN_VIEW_PERCENT && typeof getPageViewPercent === 'function') {
                            var viewPercent = getPageViewPercent();
                            if (viewPercent < CONFIG.MIN_PAGE_VIEW_PERCENT) {
                                if (CONFIG.DEBUG_MODE || CONFIG.SCROLL_DEBUG) {
                                    console.log('[handleScrollNavigation] Bloqueado (cima): Visualizou apenas', Math.round(viewPercent * 100) + '% da página (mínimo: ' + Math.round(CONFIG.MIN_PAGE_VIEW_PERCENT * 100) + '%)');
                                }
                                if (pageViewTracker && typeof pageViewTracker === 'object') {
                                    pageViewTracker.lastScrollTime = Date.now();
                                }
                                return; // Não visualizou suficiente, bloqueia navegação
                            }
                        }
                        
                        // Valida tempo mínimo na página (2s)
                        if (CONFIG.REQUIRE_MIN_PAGE_TIME && pageViewTracker && typeof pageViewTracker === 'object' && pageViewTracker.pageStartTime) {
                            var timeOnPage = Date.now() - pageViewTracker.pageStartTime;
                            if (timeOnPage < CONFIG.MIN_PAGE_TIME) {
                                if (CONFIG.DEBUG_MODE || CONFIG.SCROLL_DEBUG) {
                                    console.log('[handleScrollNavigation] Bloqueado (cima): Tempo na página insuficiente (' + Math.round(timeOnPage / 1000) + 's, mínimo: ' + CONFIG.MIN_PAGE_TIME / 1000 + 's)');
                                }
                                if (pageViewTracker && typeof pageViewTracker === 'object') {
                                    pageViewTracker.lastScrollTime = Date.now();
                                }
                                return; // Tempo insuficiente, bloqueia navegação
                            }
                        }
                        
                        // Se passou nas validações, usa startNavigationProcessTop para navegação controlada
                        // Mas apenas se ainda não iniciou o processo
                        if (pageViewTracker && typeof pageViewTracker === 'object' && 
                            (!pageViewTracker.hasReachedTop || !pageViewTracker.navigationPendingTimerTop)) {
                            // Chama onReachedTop que vai usar todas as validações
                            if (typeof onReachedTop === 'function') {
                                onReachedTop(scrollPos);
                            }
                        }
                        return; // Retorna, a navegação será feita pelo startNavigationProcessTop
                    }
                    
                    // Comportamento padrão (sem validações rigorosas): usa threshold normal
                    // Verifica se chegou ao final absoluto (dentro de 10px e 98%+)
                    if (isAtBottom) {
                        // Cancela qualquer navegação pendente anterior
                        if (pendingNavigation) {
                            clearTimeout(pendingNavigation);
                            pendingNavigation = null;
                        }
                        
                        // Verifica se a posição do scroll mudou desde a última verificação
                        var scrollChanged = !lastScrollPosition || 
                                         Math.abs(lastScrollPosition.scrollTop - scrollPos.scrollTop) > 1;
                        
                        if (scrollChanged) {
                            // Scroll ainda está mudando - atualiza posição e aguarda parar
                            lastScrollPosition = {
                                scrollTop: scrollPos.scrollTop,
                                maxScroll: scrollPos.maxScroll,
                                time: now
                            };
                            
                            // Cancela timer anterior
                            if (scrollStopTimer) {
                                clearTimeout(scrollStopTimer);
                            }
                            
                            // Aguarda o usuário parar de rolar antes de navegar
                            // Isso permite que ele leia o final da página
                            scrollStopTimer = setTimeout(function() {
                                // Verifica novamente se ainda está no final
                                try {
                                    var currentIframe = document.getElementById('iframeViewer');
                                    if (currentIframe && currentIframe.contentWindow) {
                                        var currentIframeDoc = currentIframe.contentDocument || currentIframe.contentWindow.document;
                                        var currentScrollPos = getScrollPosition(currentIframeDoc.documentElement || currentIframeDoc.body, currentIframe.contentWindow);
                                        
                                        if (currentScrollPos.atBottom && currentPage < totalPages) {
                                            if (CONFIG.SCROLL_DEBUG || CONFIG.DEBUG_MODE) {
                                                console.log('[handleScrollNavigation] Parou de rolar no final, navegando para próxima página');
                                            }
                                            lastScrollTime = Date.now();
                                            nextPagina();
                                        }
                                    }
                                } catch (e) {
                                    // Erro ao verificar - navega mesmo assim se estava no final
                                    if (CONFIG.SCROLL_DEBUG || CONFIG.DEBUG_MODE) {
                                        console.warn('[handleScrollNavigation] Erro ao verificar posição final:', e);
                                    }
                                    lastScrollTime = Date.now();
                                    nextPagina();
                                }
                                
                                pendingNavigation = null;
                                scrollStopTimer = null;
                            }, CONFIG.SCROLL_MIN_STOP_TIME || 300);
                            
                            pendingNavigation = scrollStopTimer;
                            
                            if (CONFIG.SCROLL_DEBUG || CONFIG.DEBUG_MODE) {
                                console.log('[handleScrollNavigation] Chegou ao final, aguardando parar de rolar antes de navegar', {
                                    distanceFromBottom: distanceFromBottom,
                                    scrollPercent: scrollPos.scrollPercent.toFixed(2),
                                    waitTime: CONFIG.SCROLL_MIN_STOP_TIME || 300
                                });
                            }
                        }
                        // Se não mudou, já está aguardando - não faz nada
                        return;
                    }
                    // Caso 2: PDF muito pequeno (maxScroll <= 10px) - já visualizou tudo
                    // Apenas para PDFs extremamente pequenos
                    else if (scrollPos.maxScroll <= 10 && scrollPos.scrollHeight > 0 && scrollPos.scrollTop > 0) {
                        // Para PDFs muito pequenos, também aguarda parar de rolar
                        if (!pendingNavigation) {
                            pendingNavigation = setTimeout(function() {
                                if (CONFIG.SCROLL_DEBUG || CONFIG.DEBUG_MODE) {
                                    console.log('[handleScrollNavigation] PDF muito pequeno, navegando após parar de rolar');
                                }
                                lastScrollTime = Date.now();
                                nextPagina();
                                pendingNavigation = null;
                            }, CONFIG.SCROLL_MIN_STOP_TIME || 300);
                        }
                        return;
                    }
                    
                    // Se não está no final, cancela qualquer navegação pendente
                    if (pendingNavigation) {
                        clearTimeout(pendingNavigation);
                        pendingNavigation = null;
                        if (CONFIG.SCROLL_DEBUG || CONFIG.DEBUG_MODE) {
                            console.log('[handleScrollNavigation] Cancelando navegação pendente - não está mais no final');
                        }
                    }
                    
                    // Atualiza última posição
                    lastScrollPosition = {
                        scrollTop: scrollPos.scrollTop,
                        maxScroll: scrollPos.maxScroll,
                        time: now
                    };
                    
                    if (CONFIG.SCROLL_DEBUG || CONFIG.DEBUG_MODE) {
                        console.log('[handleScrollNavigation] Não navegou - permitindo scroll dentro da página. scrollPos:', {
                            atBottom: scrollPos.atBottom,
                            scrollPercent: scrollPos.scrollPercent.toFixed(2),
                            maxScroll: scrollPos.maxScroll,
                            scrollTop: scrollPos.scrollTop,
                            distanceFromBottom: distanceFromBottom,
                            currentPage: currentPage,
                            totalPages: totalPages
                        });
                    }
                }
                
                // Navega para página anterior se:
                // - Está rolando para cima E chegou ao topo
                if (isScrollingUp && scrollPos.atTop && currentPage > 1) {
                    lastScrollTime = now;
                    event.preventDefault();
                    event.stopPropagation();
                    prevPagina();
                    return;
                }
            } catch (e) {
                // Erro ao acessar iframe (pode ser CORS)
                if (CONFIG.DEBUG_MODE) {
                    console.warn('[handleScrollNavigation] Erro ao acessar iframe:', e);
                }
                
                // Fallback: usa detecção de scroll contínuo
                var currentDirection = isScrollingDown ? 'down' : 'up';
                
                if (scrollDirection === currentDirection) {
                    scrollDirectionCount++;
                } else {
                    scrollDirection = currentDirection;
                    scrollDirectionCount = 1;
                }
                
                // Limpa timeout anterior
                if (scrollDirectionTimeout) {
                    clearTimeout(scrollDirectionTimeout);
                }
                
                // Reseta contador após 600ms sem scroll (aumentado para evitar navegação prematura)
                scrollDirectionTimeout = setTimeout(function() {
                    scrollDirection = null;
                    scrollDirectionCount = 0;
                }, 600);
                
                    // Navega apenas se houver scroll contínuo muito significativo
                    // Para baixo: 8+ eventos (muito restritivo - permite ler página inteira)
                    // Para cima: 3+ eventos (mais restritivo, para evitar navegação acidental)
                    var requiredCount = isScrollingDown ? 8 : 3;
                
                if (scrollDirectionCount >= requiredCount) {
                    if (isScrollingDown && currentPage < totalPages) {
                        lastScrollTime = now;
                        scrollDirectionCount = 0;
                        event.preventDefault();
                        event.stopPropagation();
                        nextPagina();
                    } else if (isScrollingUp && currentPage > 1) {
                        lastScrollTime = now;
                        scrollDirectionCount = 0;
                        event.preventDefault();
                        event.stopPropagation();
                        prevPagina();
                    }
                }
            }
        }
        
        /**
         * Inicializa a navegação por scroll
         */
        function initScrollNavigation() {
            if (!scrollNavigationEnabled || !CONFIG.SCROLL_NAVIGATION_ENABLED) {
                return;
            }
            
            var iframe = document.getElementById('iframeViewer');
            var iframeWrapper = document.querySelector('.iframe-wrapper');
            
            if (!iframe || !iframeWrapper) {
                return;
            }
            
            // Adiciona listener no wrapper do iframe
            iframeWrapper.addEventListener('wheel', handleScrollNavigation, { passive: false });
            
            // Tenta adicionar listener no iframe quando carregar
            function addIframeListener() {
                try {
                    var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    if (iframeDoc && iframeDoc.body) {
                        iframeDoc.addEventListener('wheel', handleScrollNavigation, { passive: false });
                        if (CONFIG.DEBUG_MODE) {
                            console.log('[initScrollNavigation] Listener adicionado ao iframe');
                        }
                    }
                } catch (e) {
                    // CORS ou iframe ainda não carregado
                    if (CONFIG.DEBUG_MODE) {
                        console.warn('[initScrollNavigation] Não foi possível adicionar listener ao iframe:', e);
                    }
                }
            }
            
            // Tenta adicionar quando o iframe carregar
            iframe.addEventListener('load', function() {
                setTimeout(addIframeListener, 100);
            });
            
            // Tenta imediatamente se já estiver carregado
            if (iframe.contentDocument && iframe.contentDocument.readyState === 'complete') {
                setTimeout(addIframeListener, 100);
            }
            
            if (CONFIG.DEBUG_MODE) {
                console.log('[initScrollNavigation] Navegação por scroll inicializada');
            }
        }
        
        /**
         * Habilita/desabilita navegação por scroll
         * @param {boolean} enabled - true para habilitar, false para desabilitar
         */
        function setScrollNavigationEnabled(enabled) {
            scrollNavigationEnabled = enabled;
            CONFIG.SCROLL_NAVIGATION_ENABLED = enabled;
            
            if (enabled) {
                initScrollNavigation();
                
                // Inicia rastreamento e monitoramento apenas se scroll navigation está habilitado E proteções estão habilitadas
                if (CONFIG.SCROLL_NAVIGATION_ENABLED && scrollNavigationEnabled && 
                    (CONFIG.REQUIRE_MIN_VIEW_PERCENT || CONFIG.REQUIRE_MIN_PAGE_TIME)) {
                    if (typeof resetPageViewTracking === 'function') {
                        resetPageViewTracking();
                    }
                    if (typeof startPageViewMonitoring === 'function') {
                        startPageViewMonitoring();
                    }
                }
                
                // Pré-carrega páginas adjacentes apenas se scroll navigation está habilitado
                if (CONFIG.SCROLL_NAVIGATION_ENABLED && scrollNavigationEnabled &&
                    CONFIG.PRELOAD_ONLY_ADJACENT && typeof preloadAdjacentPages === 'function') {
                    setTimeout(function() {
                        preloadAdjacentPages();
                    }, 300);
                }
            }
            
            if (CONFIG.DEBUG_MODE) {
                console.log('[setScrollNavigationEnabled] Navegação por scroll:', enabled ? 'habilitada' : 'desabilitada');
            }
        }
        
        // ============================================
        // RASTREAMENTO DE VISUALIZAÇÃO COMPLETA
        // ============================================
        
        /**
         * Reseta rastreamento ao entrar em nova página
         */
        function resetPageViewTracking() {
            // Limpa timers pendentes
            if (pageViewTracker && pageViewTracker.navigationPendingTimer) {
                clearTimeout(pageViewTracker.navigationPendingTimer);
            }
            if (pageViewTracker && pageViewTracker.navigationPendingTimerTop) {
                clearTimeout(pageViewTracker.navigationPendingTimerTop);
            }
            
            pageViewTracker = {
                pageStartTime: Date.now(),
                minScrollPosition: Infinity,
                maxScrollPosition: 0,
                scrollPath: [],
                lastScrollTime: null,
                scrollStopTimer: null,
                navigationPendingTimer: null,
                navigationPendingTimerTop: null,
                hasReachedBottom: false,
                hasReachedTop: false,
                navigationCancelled: false,
                navigationCancelledTop: false
            };
            
            if (CONFIG.DEBUG_MODE) {
                console.log('[resetPageViewTracking] Rastreamento resetado para nova página');
            }
        }
        
        /**
         * Monitora visualização da página continuamente
         * Inicia loop de monitoramento (chamado apenas uma vez)
         */
        var pageViewMonitoringActive = false;
        
        function startPageViewMonitoring() {
            // Evita iniciar múltiplas instâncias do monitoramento
            if (pageViewMonitoringActive) {
                if (CONFIG.DEBUG_MODE) {
                    console.log('[startPageViewMonitoring] Monitoramento já está ativo');
                }
                return;
            }
            
            // Verifica se proteções estão habilitadas
            if (!CONFIG.REQUIRE_MIN_VIEW_PERCENT && !CONFIG.REQUIRE_MIN_PAGE_TIME) {
                if (CONFIG.DEBUG_MODE) {
                    console.log('[startPageViewMonitoring] Proteções desabilitadas, monitoramento não necessário');
                }
                return;
            }
            
            pageViewMonitoringActive = true;
            
            function monitor() {
                // Se navegação por scroll foi desabilitada, para o monitoramento
                if (!scrollNavigationEnabled || !CONFIG.SCROLL_NAVIGATION_ENABLED) {
                    pageViewMonitoringActive = false;
                    return;
                }
                
                // Verifica se pageViewTracker existe e está inicializado
                if (!pageViewTracker || typeof pageViewTracker !== 'object') {
                    pageViewMonitoringActive = false;
                    return;
                }
                
                try {
                    var iframe = document.getElementById('iframeViewer');
                    if (!iframe) {
                        if (pageViewMonitoringActive && scrollNavigationEnabled && CONFIG.SCROLL_NAVIGATION_ENABLED) {
                            requestAnimationFrame(monitor);
                        } else {
                            pageViewMonitoringActive = false;
                        }
                        return;
                    }
                    
                    var iframeWindow = iframe.contentWindow;
                    if (!iframeWindow) {
                        if (pageViewMonitoringActive && scrollNavigationEnabled && CONFIG.SCROLL_NAVIGATION_ENABLED) {
                            requestAnimationFrame(monitor);
                        } else {
                            pageViewMonitoringActive = false;
                        }
                        return;
                    }
                    
                    var scrollPos = getScrollPosition(null, iframeWindow);
                    
                    // Verifica se obteve posição válida
                    if (!scrollPos || scrollPos.scrollHeight === 0) {
                        if (pageViewMonitoringActive && scrollNavigationEnabled && CONFIG.SCROLL_NAVIGATION_ENABLED) {
                            requestAnimationFrame(monitor);
                        } else {
                            pageViewMonitoringActive = false;
                        }
                        return;
                    }
                    
                    // Atualiza posição máxima alcançada
                    if (scrollPos.scrollTop > pageViewTracker.maxScrollPosition) {
                        pageViewTracker.maxScrollPosition = scrollPos.scrollTop;
                    }
                    
                    // Atualiza posição mínima
                    if (scrollPos.scrollTop < pageViewTracker.minScrollPosition) {
                        pageViewTracker.minScrollPosition = scrollPos.scrollTop;
                    }
                    
                    // Registra posição no caminho (para cálculo de % visualizado)
                    var currentPercent = scrollPos.scrollPercent || 0;
                    if (pageViewTracker.scrollPath.indexOf(currentPercent) === -1) {
                        pageViewTracker.scrollPath.push(currentPercent);
                    }
                    
                    // Atualiza último tempo de scroll
                    pageViewTracker.lastScrollTime = Date.now();
                    
                    // Verifica se chegou ao final (apenas se validações estão habilitadas E scroll navigation está ativo)
                    if (scrollPos.atBottom && !pageViewTracker.hasReachedBottom) {
                        pageViewTracker.hasReachedBottom = true;
                        if (typeof onReachedBottom === 'function') {
                            onReachedBottom(scrollPos);
                        }
                    }
                    
                    // Verifica se chegou ao topo (apenas se validações estão habilitadas E scroll navigation está ativo)
                    if (scrollPos.atTop && !pageViewTracker.hasReachedTop && currentPage > 1) {
                        pageViewTracker.hasReachedTop = true;
                        if (typeof onReachedTop === 'function') {
                            onReachedTop(scrollPos);
                        }
                    }
                    
                    // Atualiza indicador visual de progresso
                    if (typeof updatePageViewProgress === 'function') {
                        updatePageViewProgress(scrollPos);
                    }
                    
                    // Cancela navegação se necessário (tanto para baixo quanto para cima)
                    if (typeof cancelNavigationIfNeeded === 'function') {
                        cancelNavigationIfNeeded(scrollPos);
                    }
                    
                } catch (e) {
                    // Ignora erros de CORS
                    if (CONFIG.DEBUG_MODE) {
                        console.warn('[startPageViewMonitoring] Erro no monitoramento:', e);
                    }
                }
                
                // Continua o loop de monitoramento (chama novamente apenas se ainda estiver ativo)
                if (pageViewMonitoringActive && scrollNavigationEnabled && CONFIG.SCROLL_NAVIGATION_ENABLED) {
                    requestAnimationFrame(monitor);
                } else {
                    pageViewMonitoringActive = false;
                }
            }
            
            // Inicia loop de monitoramento
            requestAnimationFrame(monitor);
            
            if (CONFIG.DEBUG_MODE) {
                console.log('[startPageViewMonitoring] Monitoramento de visualização iniciado');
            }
        }
        
        /**
         * Calcula percentual da página visualizada
         */
        function getPageViewPercent() {
            if (pageViewTracker.scrollPath.length === 0) return 0;
            
            // Remove duplicatas e ordena
            var uniquePath = [...new Set(pageViewTracker.scrollPath)].sort(function(a, b) {
                return a - b;
            });
            
            if (uniquePath.length === 0) return 0;
            
            var maxPercent = uniquePath[uniquePath.length - 1];
            
            // Se chegou ao final (99%+), consideramos 100% visualizada
            if (maxPercent >= CONFIG.ABSOLUTE_BOTTOM_THRESHOLD) {
                return 1.0; // 100% visualizada
            }
            
            return Math.min(1.0, maxPercent);
        }
        
        /**
         * Valida todas as condições necessárias para navegação (para baixo)
         */
        function validateNavigationConditions() {
            var validations = {
                hasMinimumViewPercent: false,
                isAtAbsoluteBottom: false,
                hasStoppedScrolling: false,
                hasMinimumPageTime: false,
                notCancelled: true
            };
            
            try {
                var iframe = document.getElementById('iframeViewer');
                if (!iframe) return validations;
                
                var iframeWindow = iframe.contentWindow;
                var scrollPos = getScrollPosition(null, iframeWindow);
                
                // Validação 1: Visualizou mínimo da página (80%)
                var viewPercent = getPageViewPercent();
                validations.hasMinimumViewPercent = viewPercent >= CONFIG.MIN_PAGE_VIEW_PERCENT;
                
                // Validação 2: Está no final absoluto (99%+)
                validations.isAtAbsoluteBottom = scrollPos.scrollPercent >= CONFIG.ABSOLUTE_BOTTOM_THRESHOLD;
                
                // Validação 3: Parou de rolar (sem movimento por 500ms)
                var timeSinceLastScroll = Date.now() - (pageViewTracker.lastScrollTime || 0);
                validations.hasStoppedScrolling = timeSinceLastScroll >= CONFIG.SCROLL_STOP_TIMEOUT;
                
                // Validação 4: Tempo mínimo na página (2s)
                var timeOnPage = Date.now() - (pageViewTracker.pageStartTime || Date.now());
                validations.hasMinimumPageTime = timeOnPage >= CONFIG.MIN_PAGE_TIME;
                
                // Validação 5: Navegação não foi cancelada
                validations.notCancelled = !pageViewTracker.navigationCancelled;
                
            } catch (e) {
                // Erro ao validar - assume que não está pronto
                if (CONFIG.DEBUG_VALIDATIONS) {
                    console.warn('[validateNavigationConditions] Erro:', e);
                }
            }
            
            if (CONFIG.DEBUG_VALIDATIONS) {
                console.log('[validateNavigationConditions]', validations);
            }
            
            return validations;
        }
        
        /**
         * Valida todas as condições necessárias para navegação (para cima - página anterior)
         */
        function validateNavigationConditionsTop() {
            var validations = {
                hasMinimumViewPercent: false,
                isAtAbsoluteTop: false,
                hasStoppedScrolling: false,
                hasMinimumPageTime: false,
                notCancelled: true
            };
            
            try {
                var iframe = document.getElementById('iframeViewer');
                if (!iframe) return validations;
                
                var iframeWindow = iframe.contentWindow;
                var scrollPos = getScrollPosition(null, iframeWindow);
                
                // Validação 1: Visualizou mínimo da página (80%)
                // Para navegação para cima, também precisa ter visualizado a página atual
                var viewPercent = getPageViewPercent();
                validations.hasMinimumViewPercent = viewPercent >= CONFIG.MIN_PAGE_VIEW_PERCENT;
                
                // Validação 2: Está no topo absoluto (1% ou menos)
                validations.isAtAbsoluteTop = scrollPos.scrollPercent <= CONFIG.ABSOLUTE_TOP_THRESHOLD;
                
                // Validação 3: Parou de rolar (sem movimento por 500ms)
                var timeSinceLastScroll = Date.now() - (pageViewTracker.lastScrollTime || 0);
                validations.hasStoppedScrolling = timeSinceLastScroll >= CONFIG.SCROLL_STOP_TIMEOUT;
                
                // Validação 4: Tempo mínimo na página (2s)
                var timeOnPage = Date.now() - (pageViewTracker.pageStartTime || Date.now());
                validations.hasMinimumPageTime = timeOnPage >= CONFIG.MIN_PAGE_TIME;
                
                // Validação 5: Navegação não foi cancelada
                validations.notCancelled = !pageViewTracker.navigationCancelledTop;
                
            } catch (e) {
                // Erro ao validar - assume que não está pronto
                if (CONFIG.DEBUG_VALIDATIONS) {
                    console.warn('[validateNavigationConditionsTop] Erro:', e);
                }
            }
            
            if (CONFIG.DEBUG_VALIDATIONS) {
                console.log('[validateNavigationConditionsTop]', validations);
            }
            
            return validations;
        }
        
        /**
         * Chamado quando usuário chega ao final da página
         */
        function onReachedBottom(scrollPos) {
            if (CONFIG.DEBUG_MODE) {
                console.log('[onReachedBottom] Chegou ao final da página');
            }
            
            // Cancela qualquer navegação pendente anterior
            if (pageViewTracker.navigationPendingTimer) {
                clearTimeout(pageViewTracker.navigationPendingTimer);
                pageViewTracker.navigationPendingTimer = null;
            }
            
            // Valida condições
            var validations = validateNavigationConditions();
            
            // Se não passou nas validações críticas, não navega
            if (CONFIG.REQUIRE_MIN_VIEW_PERCENT && !validations.hasMinimumViewPercent) {
                if (CONFIG.DEBUG_MODE) {
                    console.log('[onReachedBottom] Bloqueado: Usuário não visualizou mínimo da página');
                }
                return;
            }
            
            if (!validations.isAtAbsoluteBottom) {
                // Não está no final absoluto ainda
                return;
            }
            
            // Inicia processo de navegação com timeout de segurança
            startNavigationProcess();
        }
        
        /**
         * Chamado quando usuário chega ao topo da página (para navegação para cima)
         */
        function onReachedTop(scrollPos) {
            if (CONFIG.DEBUG_MODE) {
                console.log('[onReachedTop] Chegou ao topo da página');
            }
            
            // Só navega para cima se não estiver na primeira página
            if (currentPage <= 1) {
                if (CONFIG.DEBUG_MODE) {
                    console.log('[onReachedTop] Já está na primeira página, não navega');
                }
                return;
            }
            
            // Cancela qualquer navegação pendente anterior
            if (pageViewTracker.navigationPendingTimerTop) {
                clearTimeout(pageViewTracker.navigationPendingTimerTop);
                pageViewTracker.navigationPendingTimerTop = null;
            }
            
            // Valida condições
            var validations = validateNavigationConditionsTop();
            
            // Se não passou nas validações críticas, não navega
            if (CONFIG.REQUIRE_MIN_VIEW_PERCENT && !validations.hasMinimumViewPercent) {
                if (CONFIG.DEBUG_MODE) {
                    console.log('[onReachedTop] Bloqueado: Usuário não visualizou mínimo da página');
                }
                return;
            }
            
            if (!validations.isAtAbsoluteTop) {
                // Não está no topo absoluto ainda
                return;
            }
            
            // Inicia processo de navegação para cima com timeout de segurança
            startNavigationProcessTop();
        }
        
        /**
         * Inicia processo de navegação com todas as validações
         */
        function startNavigationProcess() {
            // Cancela timer anterior se existir
            if (pageViewTracker.navigationPendingTimer) {
                clearTimeout(pageViewTracker.navigationPendingTimer);
            }
            
            // Marca que navegação está pendente
            pageViewTracker.navigationCancelled = false;
            
            // Valida condições novamente
            var validations = validateNavigationConditions();
            
            // Se todas as validações passaram, inicia timeout final
            if (validations.hasMinimumViewPercent && 
                validations.isAtAbsoluteBottom && 
                validations.hasStoppedScrolling &&
                validations.hasMinimumPageTime &&
                validations.notCancelled) {
                
                // Aguarda tempo adicional de confirmação (300ms)
                pageViewTracker.navigationPendingTimer = setTimeout(function() {
                    // Valida UMA ÚLTIMA VEZ antes de navegar
                    var finalValidations = validateNavigationConditions();
                    
                    if (finalValidations.hasMinimumViewPercent && 
                        finalValidations.isAtAbsoluteBottom && 
                        finalValidations.hasStoppedScrolling &&
                        finalValidations.hasMinimumPageTime &&
                        finalValidations.notCancelled) {
                        
                        // TODAS as condições atendidas: NAVEGA
                        executeNavigation();
                    } else {
                        // Condições mudaram, cancela navegação
                        if (CONFIG.DEBUG_MODE) {
                            console.log('[startNavigationProcess] Navegação cancelada - condições mudaram');
                        }
                        pageViewTracker.navigationPendingTimer = null;
                    }
                }, CONFIG.ADDITIONAL_CONFIRMATION_TIME);
                
            } else {
                // Não passou em todas as validações, aguarda mais tempo no final
                pageViewTracker.navigationPendingTimer = setTimeout(function() {
                    // Tenta novamente após tempo mínimo parado (800ms)
                    var timeSinceBottom = Date.now() - (pageViewTracker.lastScrollTime || Date.now());
                    
                    if (timeSinceBottom >= CONFIG.MIN_STOP_TIME) {
                        // Aguardou tempo suficiente, tenta navegar novamente
                        startNavigationProcess();
                    }
                }, CONFIG.MIN_STOP_TIME);
            }
        }
        
        /**
         * Cancela navegação se usuário voltar a rolar ou sair do final/topo
         */
        function cancelNavigationIfNeeded(scrollPos) {
            // Se usuário saiu do final absoluto, cancela navegação para baixo
            if (scrollPos.scrollPercent < CONFIG.ABSOLUTE_BOTTOM_THRESHOLD) {
                if (pageViewTracker.navigationPendingTimer) {
                    clearTimeout(pageViewTracker.navigationPendingTimer);
                    pageViewTracker.navigationPendingTimer = null;
                    pageViewTracker.navigationCancelled = true;
                    pageViewTracker.hasReachedBottom = false; // Reseta flag
                    
                    if (CONFIG.DEBUG_MODE) {
                        console.log('[cancelNavigationIfNeeded] Navegação para baixo cancelada - usuário saiu do final');
                    }
                }
            }
            
            // Se usuário saiu do topo absoluto, cancela navegação para cima
            if (scrollPos.scrollPercent > CONFIG.ABSOLUTE_TOP_THRESHOLD) {
                if (pageViewTracker.navigationPendingTimerTop) {
                    clearTimeout(pageViewTracker.navigationPendingTimerTop);
                    pageViewTracker.navigationPendingTimerTop = null;
                    pageViewTracker.navigationCancelledTop = true;
                    pageViewTracker.hasReachedTop = false; // Reseta flag
                    
                    if (CONFIG.DEBUG_MODE) {
                        console.log('[cancelNavigationIfNeeded] Navegação para cima cancelada - usuário saiu do topo');
                    }
                }
            }
            
            // Se usuário voltou a rolar, cancela navegação pendente
            if (pageViewTracker.navigationPendingTimer && 
                Date.now() - pageViewTracker.lastScrollTime < CONFIG.SCROLL_STOP_TIMEOUT) {
                clearTimeout(pageViewTracker.navigationPendingTimer);
                pageViewTracker.navigationPendingTimer = null;
                pageViewTracker.navigationCancelled = true;
                pageViewTracker.hasReachedBottom = false; // Reseta flag
                
                if (CONFIG.DEBUG_MODE) {
                    console.log('[cancelNavigationIfNeeded] Navegação para baixo cancelada - usuário voltou a rolar');
                }
            }
            
            // Se usuário voltou a rolar, cancela navegação para cima pendente
            if (pageViewTracker.navigationPendingTimerTop && 
                Date.now() - pageViewTracker.lastScrollTime < CONFIG.SCROLL_STOP_TIMEOUT) {
                clearTimeout(pageViewTracker.navigationPendingTimerTop);
                pageViewTracker.navigationPendingTimerTop = null;
                pageViewTracker.navigationCancelledTop = true;
                pageViewTracker.hasReachedTop = false; // Reseta flag
                
                if (CONFIG.DEBUG_MODE) {
                    console.log('[cancelNavigationIfNeeded] Navegação para cima cancelada - usuário voltou a rolar');
                }
            }
        }
        
        /**
         * Executa navegação para próxima página (após todas as validações)
         */
        function executeNavigation() {
            if (CONFIG.DEBUG_MODE) {
                console.log('[executeNavigation] Navegando para próxima página (abrirá no TOPO)');
            }
            
            // Limpa timers
            if (pageViewTracker.navigationPendingTimer) {
                clearTimeout(pageViewTracker.navigationPendingTimer);
                pageViewTracker.navigationPendingTimer = null;
            }
            
            // Navega para próxima página (já define lastNavigationDirection = 'down' no nextPagina)
            if (currentPage < totalPages) {
                nextPagina(); // Isso define lastNavigationDirection = 'down' (abrir no topo)
                
                // Reseta rastreamento para nova página após um delay
                setTimeout(function() {
                    resetPageViewTracking();
                }, 500);
            }
        }
        
        /**
         * Inicia processo de navegação para cima (página anterior) com todas as validações
         */
        function startNavigationProcessTop() {
            // Cancela timer anterior se existir
            if (pageViewTracker.navigationPendingTimerTop) {
                clearTimeout(pageViewTracker.navigationPendingTimerTop);
            }
            
            // Marca que navegação está pendente
            pageViewTracker.navigationCancelledTop = false;
            
            // Valida condições novamente
            var validations = validateNavigationConditionsTop();
            
            // Se todas as validações passaram, inicia timeout final
            if (validations.hasMinimumViewPercent && 
                validations.isAtAbsoluteTop && 
                validations.hasStoppedScrolling &&
                validations.hasMinimumPageTime &&
                validations.notCancelled) {
                
                // Aguarda tempo adicional de confirmação (300ms)
                pageViewTracker.navigationPendingTimerTop = setTimeout(function() {
                    // Valida UMA ÚLTIMA VEZ antes de navegar
                    var finalValidations = validateNavigationConditionsTop();
                    
                    if (finalValidations.hasMinimumViewPercent && 
                        finalValidations.isAtAbsoluteTop && 
                        finalValidations.hasStoppedScrolling &&
                        finalValidations.hasMinimumPageTime &&
                        finalValidations.notCancelled) {
                        
                        // TODAS as condições atendidas: NAVEGA PARA CIMA
                        executeNavigationTop();
                    } else {
                        // Condições mudaram, cancela navegação
                        if (CONFIG.DEBUG_MODE) {
                            console.log('[startNavigationProcessTop] Navegação cancelada - condições mudaram');
                        }
                        pageViewTracker.navigationPendingTimerTop = null;
                    }
                }, CONFIG.ADDITIONAL_CONFIRMATION_TIME);
                
            } else {
                // Não passou em todas as validações, aguarda mais tempo no topo
                pageViewTracker.navigationPendingTimerTop = setTimeout(function() {
                    // Tenta novamente após tempo mínimo parado (800ms)
                    var timeSinceTop = Date.now() - (pageViewTracker.lastScrollTime || Date.now());
                    
                    if (timeSinceTop >= CONFIG.MIN_STOP_TIME) {
                        // Aguardou tempo suficiente, tenta navegar novamente
                        startNavigationProcessTop();
                    }
                }, CONFIG.MIN_STOP_TIME);
            }
        }
        
        /**
         * Executa navegação para página anterior (após todas as validações)
         * A página anterior será aberta no FINAL (base)
         */
        function executeNavigationTop() {
            if (CONFIG.DEBUG_MODE) {
                console.log('[executeNavigationTop] Navegando para página anterior (abrirá no FINAL)');
            }
            
            // Limpa timers
            if (pageViewTracker.navigationPendingTimerTop) {
                clearTimeout(pageViewTracker.navigationPendingTimerTop);
                pageViewTracker.navigationPendingTimerTop = null;
            }
            
            // Navega para página anterior (já define lastNavigationDirection = 'up' no prevPagina)
            if (currentPage > 1) {
                prevPagina(); // Isso define lastNavigationDirection = 'up' (abrir no final)
                
                // Reseta rastreamento para nova página após um delay
                setTimeout(function() {
                    resetPageViewTracking();
                }, 500);
            }
        }
        
        /**
         * Atualiza indicador visual de progresso de visualização
         */
        function updatePageViewProgress(scrollPos) {
            // Implementação opcional de UI - pode ser adicionada depois
        }
        
        // ============================================
        // PRÉ-CARREGAMENTO OTIMIZADO (APENAS ADJACENTES)
        // ============================================
        
        /**
         * Pré-carrega APENAS páginas adjacentes (anterior e próxima)
         * OTIMIZADO para documentos grandes (milhares de páginas)
         * NUNCA pré-carrega mais que 2 páginas (anterior + próxima)
         */
        function preloadAdjacentPages() {
            // Verifica se scroll navigation está habilitado (pré-requisito para pré-carregamento)
            if (!CONFIG.SCROLL_NAVIGATION_ENABLED || !scrollNavigationEnabled) {
                if (CONFIG.DEBUG_MODE) {
                    console.log('[preloadAdjacentPages] Scroll navigation desabilitado, pré-carregamento não necessário');
                }
                return; // Scroll navigation desabilitado, não faz pré-carregamento
            }
            
            // Verifica se pré-carregamento está habilitado e otimizado
            if (!CONFIG.PRELOAD_ONLY_ADJACENT) {
                if (CONFIG.DEBUG_MODE) {
                    console.log('[preloadAdjacentPages] Pré-carregamento otimizado desabilitado');
                }
                return; // Pré-carregamento desabilitado ou não otimizado
            }
            
            // Limpa cache de páginas que não são mais adjacentes
            cleanupNonAdjacentPages();
            
            // Pré-carrega PRÓXIMA página (se existir e ainda não está em cache)
            if (CONFIG.PRELOAD_NEXT && currentPage < totalPages) {
                var nextPageNum = currentPage + 1;
                
                // Verifica se já está em cache
                if (!pageCache.next || pageCache.next.pageNum !== nextPageNum) {
                    preloadPage(nextPageNum, 'next');
                }
            } else {
                // Não há próxima página ou pré-carregamento desabilitado
                if (pageCache.next) {
                    unloadPageFromCache(pageCache.next.pageNum);
                    pageCache.next = null;
                }
            }
            
            // Pré-carrega PÁGINA ANTERIOR (se existir e ainda não está em cache)
            if (CONFIG.PRELOAD_PREV && currentPage > 1) {
                var prevPageNum = currentPage - 1;
                
                // Verifica se já está em cache
                if (!pageCache.previous || pageCache.previous.pageNum !== prevPageNum) {
                    preloadPage(prevPageNum, 'previous');
                }
            } else {
                // Não há página anterior (estamos na primeira página)
                if (pageCache.previous) {
                    unloadPageFromCache(pageCache.previous.pageNum);
                    pageCache.previous = null;
                }
            }
            
            // Atualiza página atual no cache
            pageCache.current = {
                pageNum: currentPage,
                loaded: true,
                url: getPageUrl(currentPage)
            };
            
            if (CONFIG.DEBUG_MODE) {
                console.log('[preloadAdjacentPages] Cache atualizado:', {
                    current: pageCache.current?.pageNum,
                    previous: pageCache.previous?.pageNum,
                    next: pageCache.next?.pageNum,
                    cacheSize: Object.keys(pageCache.iframes).length
                });
            }
        }
        
        /**
         * Pré-carrega uma página específica
         * @param {number} pageNum - Número da página a pré-carregar
         * @param {string} position - 'previous' ou 'next'
         */
        function preloadPage(pageNum, position) {
            // Verifica se já está em cache
            if (pageCache.iframes[pageNum]) {
                if (CONFIG.DEBUG_MODE) {
                    console.log('[preloadPage] Página', pageNum, 'já está em cache');
                }
                updateCachePosition(pageNum, position);
                return;
            }
            
            // Limita tamanho do cache (nunca mais que 3 páginas)
            if (Object.keys(pageCache.iframes).length >= CONFIG.MAX_CACHE_SIZE) {
                if (CONFIG.DEBUG_MODE) {
                    console.log('[preloadPage] Cache cheio, limpando antes de adicionar página', pageNum);
                }
                cleanupNonAdjacentPages(); // Limpa antes de adicionar nova
            }
            
            var pageUrl = getPageUrl(pageNum);
            if (!pageUrl) {
                if (CONFIG.DEBUG_MODE) {
                    console.warn('[preloadPage] URL não encontrada para página', pageNum);
                }
                return;
            }
            
            // Cria iframe oculto para pré-carregamento
            var hiddenIframe = document.createElement('iframe');
            hiddenIframe.style.display = 'none';
            hiddenIframe.style.width = '0';
            hiddenIframe.style.height = '0';
            hiddenIframe.style.border = 'none';
            hiddenIframe.setAttribute('data-page-num', pageNum);
            hiddenIframe.setAttribute('data-cache-position', position);
            
            // Armazena no cache antes de carregar
            pageCache.iframes[pageNum] = hiddenIframe;
            
            // Atualiza posição no cache
            if (position === 'next') {
                pageCache.next = {
                    pageNum: pageNum,
                    loaded: false,
                    url: pageUrl,
                    iframe: hiddenIframe
                };
            } else if (position === 'previous') {
                pageCache.previous = {
                    pageNum: pageNum,
                    loaded: false,
                    url: pageUrl,
                    iframe: hiddenIframe
                };
            }
            
            // Event listener para quando carregar
            hiddenIframe.addEventListener('load', function() {
                if (position === 'next') {
                    pageCache.next.loaded = true;
                } else if (position === 'previous') {
                    pageCache.previous.loaded = true;
                }
                
                if (CONFIG.DEBUG_MODE) {
                    console.log('[preloadPage] Página', pageNum, 'pré-carregada com sucesso');
                }
            }, { once: true });
            
            hiddenIframe.addEventListener('error', function() {
                // Remove do cache em caso de erro
                unloadPageFromCache(pageNum);
                
                if (CONFIG.DEBUG_MODE) {
                    console.warn('[preloadPage] Erro ao pré-carregar página', pageNum);
                }
            }, { once: true });
            
            // Adiciona ao DOM e inicia carregamento
            document.body.appendChild(hiddenIframe);
            hiddenIframe.src = pageUrl;
            
            if (CONFIG.DEBUG_MODE) {
                console.log('[preloadPage] Iniciando pré-carregamento da página', pageNum, '(' + position + ')');
            }
        }
        
        /**
         * Remove página do cache e do DOM
         */
        function unloadPageFromCache(pageNum) {
            if (pageCache.iframes[pageNum]) {
                var iframe = pageCache.iframes[pageNum];
                
                // Remove event listeners
                iframe.src = 'about:blank';
                
                // Remove do DOM
                if (iframe.parentNode) {
                    iframe.parentNode.removeChild(iframe);
                }
                
                // Remove do cache
                delete pageCache.iframes[pageNum];
                
                // Atualiza referências
                if (pageCache.previous && pageCache.previous.pageNum === pageNum) {
                    pageCache.previous = null;
                }
                if (pageCache.next && pageCache.next.pageNum === pageNum) {
                    pageCache.next = null;
                }
                
                if (CONFIG.DEBUG_MODE) {
                    console.log('[unloadPageFromCache] Página', pageNum, 'removida do cache');
                }
            }
        }
        
        /**
         * Limpa páginas do cache que não são mais adjacentes
         * Garante que cache nunca tenha mais que 3 páginas (atual, anterior, próxima)
         */
        function cleanupNonAdjacentPages() {
            if (!CONFIG.CLEANUP_OLD_CACHE) {
                return;
            }
            
            var pagesToKeep = new Set();
            
            // Mantém página atual
            if (pageCache.current) {
                pagesToKeep.add(pageCache.current.pageNum);
            }
            
            // Mantém página anterior (se existe e está na posição correta)
            if (pageCache.previous && pageCache.previous.pageNum === currentPage - 1) {
                pagesToKeep.add(pageCache.previous.pageNum);
            }
            
            // Mantém próxima página (se existe e está na posição correta)
            if (pageCache.next && pageCache.next.pageNum === currentPage + 1) {
                pagesToKeep.add(pageCache.next.pageNum);
            }
            
            // Remove todas as páginas que não são adjacentes
            for (var pageNum in pageCache.iframes) {
                pageNum = parseInt(pageNum);
                
                // Se não está na lista de manter e não é a página atual, remove
                if (!pagesToKeep.has(pageNum) && pageNum !== currentPage) {
                    unloadPageFromCache(pageNum);
                }
            }
            
            // Garante que nunca temos mais que MAX_CACHE_SIZE páginas
            var cacheSize = Object.keys(pageCache.iframes).length;
            if (cacheSize > CONFIG.MAX_CACHE_SIZE) {
                // Remove páginas mais antigas primeiro (exceto adjacentes)
                var sortedPages = Object.keys(pageCache.iframes)
                    .map(function(p) { return parseInt(p); })
                    .filter(function(p) { return !pagesToKeep.has(p) && p !== currentPage; })
                    .sort(function(a, b) { return Math.abs(a - currentPage) - Math.abs(b - currentPage); });
                
                var toRemove = sortedPages.slice(0, cacheSize - CONFIG.MAX_CACHE_SIZE);
                toRemove.forEach(function(pageNum) {
                    unloadPageFromCache(pageNum);
                });
            }
            
            if (CONFIG.DEBUG_MODE && Object.keys(pageCache.iframes).length > 0) {
                console.log('[cleanupNonAdjacentPages] Cache limpo. Páginas restantes:', Object.keys(pageCache.iframes));
            }
        }
        
        /**
         * Atualiza posição de uma página já em cache
         */
        function updateCachePosition(pageNum, newPosition) {
            if (pageCache.iframes[pageNum]) {
                var iframe = pageCache.iframes[pageNum];
                iframe.setAttribute('data-cache-position', newPosition);
                
                if (newPosition === 'next') {
                    pageCache.next = {
                        pageNum: pageNum,
                        loaded: iframe.contentDocument?.readyState === 'complete',
                        url: getPageUrl(pageNum),
                        iframe: iframe
                    };
                } else if (newPosition === 'previous') {
                    pageCache.previous = {
                        pageNum: pageNum,
                        loaded: iframe.contentDocument?.readyState === 'complete',
                        url: getPageUrl(pageNum),
                        iframe: iframe
                    };
                }
            }
        }
        
        /**
         * Obtém URL de uma página específica
         */
        function getPageUrl(pageNum) {
            // Procura página nos documentos
            if (typeof APP_DATA !== 'undefined' && APP_DATA.pasta && APP_DATA.pasta.documentos) {
                for (var i = 0; i < APP_DATA.pasta.documentos.length; i++) {
                    var doc = APP_DATA.pasta.documentos[i];
                    if (doc.paginas) {
                        for (var j = 0; j < doc.paginas.length; j++) {
                            var pagina = doc.paginas[j];
                            if (parseInt(pagina.num_pagina) === pageNum) {
                                // Garante que a URL tenha cache-busting (adiciona se não tiver)
                                var url = pagina.url;
                                if (url && url.indexOf('&_t=') === -1 && url.indexOf('?_t=') === -1) {
                                    url += (url.indexOf('?') === -1 ? '?' : '&') + '_t=' + Date.now();
                                }
                                return url;
                            }
                        }
                    }
                }
            }
            
            // Fallback: constrói URL padrão usando APP_DATA
            var portalUrl = (typeof APP_DATA !== 'undefined' && APP_DATA.portal_url) ? APP_DATA.portal_url : window.location.origin + window.location.pathname;
            var codMateria = (typeof APP_DATA !== 'undefined' && APP_DATA.cod_materia) ? APP_DATA.cod_materia : '';
            
            if (!portalUrl || !codMateria) {
                if (CONFIG.DEBUG_MODE) {
                    console.warn('[getPageUrl] Dados insuficientes - portalUrl:', portalUrl, 'codMateria:', codMateria);
                }
                return null;
            }
            
            // Remove /consultas/materia da URL base se existir
            var baseUrl = portalUrl;
            if (baseUrl.includes('/consultas/materia')) {
                baseUrl = baseUrl.replace('/consultas/materia', '');
            }
            baseUrl = baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;
            
            // Formata o número da página como pg_XXXX.pdf
            var paginaFormatada = 'pg_' + String(pageNum).padStart(4, '0') + '.pdf';
            
            // Constrói a URL completa com cache busting
            var cacheBust = '&_t=' + Date.now();
            var url = baseUrl + '/@@pagina_processo_leg_integral?cod_materia=' + encodeURIComponent(codMateria) + '&pagina=' + encodeURIComponent(paginaFormatada) + cacheBust;
            
            if (CONFIG.DEBUG_MODE) {
                console.log('[getPageUrl] URL construída para página', pageNum, ':', url);
            }
            
            return url;
        }
        
        function goToPage(pagina) {
            if (!pagina || pagina < 1 || pagina > totalPages) {
                showToast('error', 'Página Inválida', 'Por favor, insira um número de página válido entre 1 e ' + totalPages, 3000);
                // Restaura valor anterior
                var paginaEl = document.getElementById('page-input');
                if (paginaEl) paginaEl.value = currentPage;
                // Anuncia erro para screen readers
                var pageError = document.getElementById('page-error');
                if (pageError) {
                    pageError.textContent = 'Página inválida. Digite um número entre 1 e ' + totalPages;
                }
                if (typeof announceToScreenReader === 'function') {
                    announceToScreenReader('Página inválida. Digite um número entre 1 e ' + totalPages);
                }
                return;
            }
            
            var paginaEl = document.getElementById('page-input');
            if (paginaEl) {
                paginaEl.value = pagina;
                paginaEl.setAttribute('aria-invalid', 'false');
            }
            
            // Limpa mensagem de erro
            var pageError = document.getElementById('page-error');
            if (pageError) {
                pageError.textContent = '';
            }
            
            currentPage = pagina;
            
            // Atualiza documento atual
            var newDocIndex = findCurrentDocumento(pagina);
            if (newDocIndex !== currentDocumentoIndex && newDocIndex >= 0) {
                currentDocumentoIndex = newDocIndex;
                updateDocumentNavigation();
            }
            
            // Anuncia mudança de página para screen readers
            if (typeof announceToScreenReader === 'function') {
                announceToScreenReader('Página ' + pagina + ' de ' + totalPages);
            }
            
            goPagina();
        }
        
        /**
         * Ajusta posição do scroll após carregar página baseado na direção da navegação
         * @param {Window} iframeWindow - Janela do iframe
         * @param {string} direction - Direção da navegação: 'down' (topo) ou 'up' (final)
         */
        function adjustScrollPosition(iframeWindow, direction) {
            if (!iframeWindow || !direction) {
                if (CONFIG.DEBUG_MODE) {
                    console.log('[adjustScrollPosition] Sem iframeWindow ou direction:', { iframeWindow: !!iframeWindow, direction: direction });
                }
                return; // Sem direção especificada, não ajusta
            }
            
            if (CONFIG.DEBUG_MODE) {
                console.log('[adjustScrollPosition] Iniciando ajuste de scroll, direção:', direction);
            }
            
            // Função auxiliar para tentar ajustar o scroll
            function tryAdjustScroll(attempt, maxAttempts) {
                try {
                    // Tenta múltiplas janelas para encontrar onde o PDF está renderizado
                    var windows = [iframeWindow];
                    
                    // Tenta acessar frames se disponível
                    try {
                        if (iframeWindow.frames && iframeWindow.frames.length > 0) {
                            for (var i = 0; i < iframeWindow.frames.length; i++) {
                                try {
                                    var frame = iframeWindow.frames[i];
                                    if (frame && frame.document) {
                                        windows.push(frame);
                                    }
                                } catch (e) {
                                    // CORS - ignora este frame
                                }
                            }
                        }
                    } catch (e) {
                        // CORS - ignora
                    }
                    
                    var bestScrollPos = null;
                    var bestWindow = null;
                    
                    // Testa todas as janelas e escolhe a que tem o maior maxScroll
                    for (var i = 0; i < windows.length; i++) {
                        try {
                            var testWindow = windows[i];
                            var testScrollPos = getScrollPosition(null, testWindow);
                            
                            if (CONFIG.DEBUG_MODE && attempt === 1) {
                                console.log('[adjustScrollPosition] Testando janela', i, '- scrollPos:', {
                                    scrollTop: testScrollPos.scrollTop,
                                    maxScroll: testScrollPos.maxScroll,
                                    scrollHeight: testScrollPos.scrollHeight,
                                    clientHeight: testScrollPos.clientHeight
                                });
                            }
                            
                            // Escolhe a janela com o maior maxScroll (mais provável de ser o PDF renderizado)
                            // MAS só considera se tiver scroll disponível (scrollHeight > clientHeight)
                            if (testScrollPos.scrollHeight > testScrollPos.clientHeight) {
                                if (!bestScrollPos || testScrollPos.maxScroll > bestScrollPos.maxScroll) {
                                    bestScrollPos = testScrollPos;
                                    bestWindow = testWindow;
                                }
                            }
                        } catch (e) {
                            // CORS - ignora esta janela
                            if (CONFIG.DEBUG_MODE && attempt === 1) {
                                console.log('[adjustScrollPosition] Erro ao acessar janela', i, ':', e.message);
                            }
                        }
                    }
                    
                    // Se não encontrou nenhuma janela válida, usa a primeira
                    if (!bestWindow) {
                        bestWindow = iframeWindow;
                        bestScrollPos = getScrollPosition(null, bestWindow);
                    }
                    
                    var scrollPos = bestScrollPos;
                    var targetWindow = bestWindow;
                    
                    // Verifica se o PDF.js terminou de renderizar (scrollHeight > clientHeight)
                    var hasScrollableContent = scrollPos.scrollHeight > scrollPos.clientHeight;
                    
                    // Tenta verificar se o PDF.js renderizou verificando elementos do viewer
                    var pdfjsRendered = false;
                    try {
                        var iframeDoc = iframeWindow.document;
                        if (iframeDoc) {
                            // Verifica se há canvas ou elementos de página renderizados
                            var canvas = iframeDoc.querySelector('canvas');
                            var pageContainer = iframeDoc.querySelector('#pageContainer') || iframeDoc.querySelector('.page');
                            pdfjsRendered = !!(canvas || pageContainer);
                            
                            if (CONFIG.DEBUG_MODE && attempt === 1) {
                                console.log('[adjustScrollPosition] Verificação PDF.js renderizado:', {
                                    hasCanvas: !!canvas,
                                    hasPageContainer: !!pageContainer,
                                    pdfjsRendered: pdfjsRendered
                                });
                            }
                        }
                    } catch (e) {
                        // CORS - ignora
                    }
                    
                    if (CONFIG.DEBUG_MODE) {
                        console.log('[adjustScrollPosition] Tentativa', attempt, '- Posição atual:', {
                            scrollTop: scrollPos.scrollTop,
                            maxScroll: scrollPos.maxScroll,
                            scrollPercent: scrollPos.scrollPercent,
                            scrollHeight: scrollPos.scrollHeight,
                            clientHeight: scrollPos.clientHeight,
                            hasScrollableContent: hasScrollableContent
                        });
                    }
                    
                    // Se estamos tentando rolar para cima e ainda não há scroll disponível
                    if (direction === 'up' && !hasScrollableContent) {
                        // Se o PDF.js já renderizou mas não há scroll, assume que o PDF não tem scroll
                        // (página pequena que cabe inteira na viewport)
                        if (pdfjsRendered && attempt >= 3) {
                            if (CONFIG.DEBUG_MODE) {
                                console.log('[adjustScrollPosition] PDF.js renderizou mas não há scroll disponível. PDF provavelmente não tem scroll (página pequena). Assumindo que já está no final.');
                            }
                            // Não há scroll, então não há como rolar para o final
                            // A página já está na posição correta (sem scroll = já está "no final")
                            return; // Termina sem fazer nada
                        }
                        
                        // Se o PDF.js ainda não renderizou, aguarda
                        if (CONFIG.DEBUG_MODE) {
                            console.warn('[adjustScrollPosition] PDF.js ainda não renderizou completamente (scrollHeight:', scrollPos.scrollHeight, '== clientHeight:', scrollPos.clientHeight, '), aguardando... (tentativa', attempt, 'de', maxAttempts, ')');
                        }
                        if (attempt < maxAttempts) {
                            // Delay progressivo aumenta com cada tentativa
                            var delay = Math.min(2000, 500 + (attempt * 300)); // 500ms, 800ms, 1100ms, 1400ms, 1700ms, 2000ms...
                            setTimeout(function() {
                                tryAdjustScroll(attempt + 1, maxAttempts);
                            }, delay);
                        } else {
                            if (CONFIG.DEBUG_MODE) {
                                console.warn('[adjustScrollPosition] Máximo de tentativas atingido. PDF.js pode não ter renderizado completamente ou o PDF não tem scroll (página muito pequena).');
                            }
                        }
                        return; // Sai e tenta novamente
                    }
                    
                    if (direction === 'down') {
                        // Navegação para baixo: rola para o TOPO (scrollTop = 0)
                        if (targetWindow.scrollTo) {
                            targetWindow.scrollTo(0, 0);
                            if (CONFIG.DEBUG_MODE) {
                                console.log('[adjustScrollPosition] Scroll ajustado para TOPO usando scrollTo(0, 0)');
                            }
                        } else if (targetWindow.scrollY !== undefined) {
                            targetWindow.scrollY = 0;
                            if (CONFIG.DEBUG_MODE) {
                                console.log('[adjustScrollPosition] Scroll ajustado para TOPO usando scrollY = 0');
                            }
                        }
                        
                        // Verifica se funcionou após um pequeno delay
                        setTimeout(function() {
                            try {
                                var checkPos = getScrollPosition(null, targetWindow);
                                if (checkPos.scrollTop > 5 && attempt < maxAttempts) {
                                    // Ainda não está no topo, tenta novamente
                                    if (CONFIG.DEBUG_MODE) {
                                        console.log('[adjustScrollPosition] Ainda não está no topo (scrollTop:', checkPos.scrollTop, '), tentando novamente...');
                                    }
                                    tryAdjustScroll(attempt + 1, maxAttempts);
                                } else if (checkPos.scrollTop <= 5) {
                                    if (CONFIG.DEBUG_MODE) {
                                        console.log('[adjustScrollPosition] ✓ Scroll ajustado para TOPO com sucesso');
                                    }
                                }
                            } catch (e) {
                                if (CONFIG.DEBUG_MODE) {
                                    console.warn('[adjustScrollPosition] Erro ao verificar posição:', e);
                                }
                            }
                        }, 100);
                        
                    } else if (direction === 'up') {
                        // Navegação para cima: rola para o FINAL (scrollTop = maxScroll)
                        // Só tenta se houver scroll disponível
                        if (hasScrollableContent && scrollPos && scrollPos.maxScroll > 0) {
                            var targetScroll = scrollPos.maxScroll;
                            
                            if (targetWindow.scrollTo) {
                                targetWindow.scrollTo(0, targetScroll);
                                if (CONFIG.DEBUG_MODE) {
                                    console.log('[adjustScrollPosition] Scroll ajustado para FINAL usando scrollTo(0,', targetScroll, ')');
                                }
                            } else if (targetWindow.scrollY !== undefined) {
                                targetWindow.scrollY = targetScroll;
                                if (CONFIG.DEBUG_MODE) {
                                    console.log('[adjustScrollPosition] Scroll ajustado para FINAL usando scrollY =', targetScroll);
                                }
                            }
                            
                            // Verifica se funcionou após um pequeno delay
                            setTimeout(function() {
                                try {
                                    var checkPos = getScrollPosition(null, targetWindow);
                                    var distanceFromBottom = checkPos.maxScroll > 0 ? checkPos.maxScroll - checkPos.scrollTop : Infinity;
                                    
                                    if (distanceFromBottom > 10 && attempt < maxAttempts) {
                                        // Ainda não está no final, tenta novamente
                                        if (CONFIG.DEBUG_MODE) {
                                            console.log('[adjustScrollPosition] Ainda não está no final (distância:', distanceFromBottom, ', scrollTop:', checkPos.scrollTop, ', maxScroll:', checkPos.maxScroll, '), tentando novamente...');
                                        }
                                        tryAdjustScroll(attempt + 1, maxAttempts);
                                    } else if (distanceFromBottom <= 10) {
                                        if (CONFIG.DEBUG_MODE) {
                                            console.log('[adjustScrollPosition] ✓ Scroll ajustado para FINAL com sucesso (scrollTop:', checkPos.scrollTop, ', maxScroll:', checkPos.maxScroll, ')');
                                        }
                                    }
                                } catch (e) {
                                    if (CONFIG.DEBUG_MODE) {
                                        console.warn('[adjustScrollPosition] Erro ao verificar posição:', e);
                                    }
                                }
                            }, 100);
                        } else {
                            // Ainda não há scroll disponível
                            // Se o PDF.js já renderizou mas não há scroll, assume que o PDF não tem scroll
                            if (pdfjsRendered && attempt >= 3) {
                                if (CONFIG.DEBUG_MODE) {
                                    console.log('[adjustScrollPosition] PDF.js renderizou mas não há scroll disponível. PDF provavelmente não tem scroll (página pequena). Assumindo que já está no final.');
                                }
                                // Não há scroll, então não há como rolar para o final
                                // A página já está na posição correta (sem scroll = já está "no final")
                                return; // Termina sem fazer nada
                            }
                            
                            // Se o PDF.js ainda não renderizou, tenta novamente
                            if (CONFIG.DEBUG_MODE) {
                                console.warn('[adjustScrollPosition] maxScroll ainda não disponível (scrollPos:', {
                                    scrollTop: scrollPos.scrollTop,
                                    maxScroll: scrollPos.maxScroll,
                                    scrollHeight: scrollPos.scrollHeight,
                                    clientHeight: scrollPos.clientHeight,
                                    hasScrollableContent: hasScrollableContent,
                                    pdfjsRendered: pdfjsRendered
                                }, '), tentando novamente... (tentativa', attempt, 'de', maxAttempts, ')');
                            }
                            if (attempt < maxAttempts) {
                                // Delay progressivo aumenta com cada tentativa
                                var delay = Math.min(2000, 500 + (attempt * 300)); // 500ms, 800ms, 1100ms, 1400ms, 1700ms, 2000ms...
                                setTimeout(function() {
                                    tryAdjustScroll(attempt + 1, maxAttempts);
                                }, delay);
                            } else {
                                if (CONFIG.DEBUG_MODE) {
                                    console.warn('[adjustScrollPosition] Máximo de tentativas atingido. PDF.js pode não ter renderizado completamente ou o PDF não tem scroll (página muito pequena).');
                                }
                            }
                        }
                    }
                } catch (e) {
                    if (CONFIG.DEBUG_MODE) {
                        console.warn('[adjustScrollPosition] Erro na tentativa', attempt, ':', e);
                    }
                    if (attempt < maxAttempts) {
                        // Delay progressivo para erros também
                        var delay = Math.min(2000, 500 + (attempt * 300)); // 500ms, 800ms, 1100ms, 1400ms, 1700ms, 2000ms...
                        setTimeout(function() {
                            tryAdjustScroll(attempt + 1, maxAttempts);
                        }, delay);
                    }
                }
            }
            
            // Aguarda o PDF.js estar completamente pronto antes de tentar ajustar
            // PDF.js precisa de tempo para renderizar o canvas e calcular as dimensões
            // Usa delays mais longos para garantir que o PDF foi renderizado
            
            // Primeira tentativa após 1s (PDF.js precisa de tempo para renderizar o canvas)
            // As tentativas recursivas dentro de tryAdjustScroll cuidam dos retries
            setTimeout(function() {
                tryAdjustScroll(1, 15); // Máximo de 15 tentativas com delays progressivos
            }, 1000);
        }
        
        function goPagina(paginaParam) {
            try {
                var paginaEl = document.getElementById('page-input');
                if (!paginaEl) return;
                
                // Se um parâmetro foi passado, usa ele; senão lê do input
                var pagina = paginaParam !== undefined ? parseInt(paginaParam) : parseInt(paginaEl.value);
                
                // Se ainda não tem valor válido, usa currentPage
                if (!pagina || isNaN(pagina)) {
                    pagina = currentPage || 1;
                }
                
                if (pagina < 1 || pagina > totalPages) {
                    showToast('error', 'Página Inválida', 'Por favor, insira um número de página válido entre 1 e ' + totalPages, 3000);
                    paginaEl.value = currentPage;
                    paginaEl.setAttribute('aria-invalid', 'true');
                    return;
                }
                
                // Atualiza o input com o valor correto e atributos de acessibilidade
                paginaEl.value = pagina;
                paginaEl.setAttribute('aria-valuenow', pagina);
                paginaEl.setAttribute('aria-valuemax', totalPages);
                paginaEl.setAttribute('aria-invalid', 'false');
            
            // Detecta direção da navegação automaticamente se não foi especificada
            // Se navegou para uma página maior, assume navegação para baixo (topo)
            // Se navegou para uma página menor, assume navegação para cima (final)
            if (!lastNavigationDirection && currentPage) {
                if (pagina > currentPage) {
                    lastNavigationDirection = 'down'; // Navegação para baixo = abrir no topo
                    if (CONFIG.DEBUG_MODE) {
                        console.log('[goPagina] Direção detectada automaticamente: DOWN (página', currentPage, '->', pagina, ')');
                    }
                } else if (pagina < currentPage) {
                    lastNavigationDirection = 'up'; // Navegação para cima = abrir no final
                    if (CONFIG.DEBUG_MODE) {
                        console.log('[goPagina] Direção detectada automaticamente: UP (página', currentPage, '->', pagina, ')');
                    }
                }
                // Se for a mesma página, mantém null (não ajusta scroll)
            }
            
            currentPage = pagina;
            
            // Remove classe active e expanded de todos os wrappers, itens e páginas
            var allWrappers = document.querySelectorAll('.doc-wrapper');
            for (var i = 0; i < allWrappers.length; i++) {
                allWrappers[i].classList.remove('active');
                // Não remove 'expanded' aqui - permite que o usuário mantenha documentos expandidos mesmo quando não estão ativos
                var items = allWrappers[i].querySelectorAll('.doc-item, .doc-page-item');
                for (var j = 0; j < items.length; j++) {
                    items[j].classList.remove('active');
                }
            }
            
            // Tenta encontrar e destacar a página correspondente
            var pageLink = document.querySelector('.doc-page-item[data-pagina-geral="' + pagina + '"]');
            if (pageLink) {
                // Encontrou link de página, marca como ativa e mostra o wrapper do documento
                pageLink.classList.add('active');
                var wrapper = pageLink.closest('.doc-wrapper');
                if (wrapper) {
                    collapseAllDocumentsExcept(wrapper); // Colapsa todos os outros
                    wrapper.classList.add('active');
                    wrapper.classList.add('expanded'); // Expande quando uma página está ativa
                    var docItem = wrapper.querySelector('.doc-item');
                    if (docItem) {
                        docItem.classList.add('active');
                    }
                }
                // Scroll automático para o item ativo
                setTimeout(function() {
                    scrollToActiveDocument();
                }, 100);
            } else {
                // Se não encontrou página exata, tenta encontrar o documento que contém esta página
                var docLinks = document.querySelectorAll('.doc-item[data-pagina-geral]');
                var bestMatch = null;
                var bestMatchPage = 0;
                for (var i = 0; i < docLinks.length; i++) {
                    var link = docLinks[i];
                    var linkPage = parseInt(link.getAttribute('data-pagina-geral'));
                    // Encontra o documento cuja página inicial é <= pagina atual e é a mais próxima
                    if (linkPage <= pagina && linkPage > bestMatchPage) {
                        bestMatch = link;
                        bestMatchPage = linkPage;
                    }
                }
                if (bestMatch) {
                    bestMatch.classList.add('active');
                    var wrapper = bestMatch.closest('.doc-wrapper');
                    if (wrapper) {
                        collapseAllDocumentsExcept(wrapper); // Colapsa todos os outros
                        wrapper.classList.add('active');
                        wrapper.classList.add('expanded'); // Expande quando documento está ativo
                    }
                    // Scroll automático para o item ativo
                    setTimeout(function() {
                        scrollToActiveDocument();
                    }, 100);
                }
            }
            
            // Constrói a URL da página dinamicamente
            // Tenta usar a URL do documento se disponível, senão constrói manualmente
            var link = null;
            var codMateria = APP_DATA.cod_materia || '';
            
            // Primeiro, tenta encontrar a URL no array de documentos
            if (APP_DATA.pasta && APP_DATA.pasta.documentos) {
                for (var i = 0; i < APP_DATA.pasta.documentos.length; i++) {
                    var doc = APP_DATA.pasta.documentos[i];
                    if (doc.paginas) {
                        for (var j = 0; j < doc.paginas.length; j++) {
                            var pag = doc.paginas[j];
                            if (parseInt(pag.num_pagina) === pagina) {
                                link = pag.url;
                                // Garante que a URL tenha cache-busting (adiciona se não tiver)
                                if (link && link.indexOf('&_t=') === -1 && link.indexOf('?_t=') === -1) {
                                    link += (link.indexOf('?') === -1 ? '?' : '&') + '_t=' + Date.now();
                                }
                                console.log('[goPagina] URL encontrada no array paginas:', link);
                                break;
                            }
                        }
                        if (link) break;
                    }
                }
            }
            
            // Se não encontrou, constrói manualmente
            if (!link) {
                console.log('[goPagina] URL não encontrada no array, construindo manualmente para página:', pagina);
                var portalUrl = APP_DATA.portal_url || '';
                
                if (!portalUrl || !codMateria) {
                    console.error('[goPagina] Dados insuficientes - portalUrl:', portalUrl, 'codMateria:', codMateria);
                    alert('Dados insuficientes para carregar a página!');
                    return;
                }
                
                // Remove /consultas/materia da URL base se existir
                var baseUrl = portalUrl;
                if (baseUrl.includes('/consultas/materia')) {
                    baseUrl = baseUrl.replace('/consultas/materia', '');
                }
                baseUrl = baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;
                
                // Formata o número da página como pg_XXXX.pdf
                var paginaFormatada = 'pg_' + String(pagina).padStart(4, '0') + '.pdf';
                
                // Constrói a URL completa com cache busting
                // Adiciona timestamp para evitar cache de versões antigas
                var cacheBust = '&_t=' + Date.now();
                link = baseUrl + '/@@pagina_processo_leg_integral?cod_materia=' + encodeURIComponent(codMateria) + '&pagina=' + encodeURIComponent(paginaFormatada) + cacheBust;
                console.log('[goPagina] URL construída manualmente:', link);
            }
            
            console.log('[goPagina] URL do PDF:', link);
            
            // Constrói a URL do PDF.js viewer
            var portalUrl = APP_DATA.portal_url || '';
            // Usa o viewer do PDF.js disponível em skins
            // O viewer.dtml é servido como /js/pdfjs/web/viewer (sem extensão)
            var pdfjsViewerUrl = portalUrl + '/js/pdfjs/web/viewer?file=' + encodeURIComponent(link);
            
            // NÃO adiciona #page=X porque cada PDF individual tem apenas 1 página
            // Quando mudamos de página, estamos mudando de arquivo PDF, não de página dentro do mesmo PDF
            // O PDF.js mostrará automaticamente a página 1 do PDF carregado
            
            console.log('[goPagina] URL do PDF.js viewer:', pdfjsViewerUrl);
            
            // RESETA rastreamento de visualização para nova página (apenas se scroll navigation está habilitado)
            if (CONFIG.SCROLL_NAVIGATION_ENABLED && scrollNavigationEnabled &&
                (CONFIG.REQUIRE_MIN_VIEW_PERCENT || CONFIG.REQUIRE_MIN_PAGE_TIME)) {
                if (typeof resetPageViewTracking === 'function') {
                    resetPageViewTracking();
                }
            }
            
            // Pré-carrega APENAS páginas adjacentes (anterior e próxima) - apenas se scroll navigation está habilitado
            if (CONFIG.SCROLL_NAVIGATION_ENABLED && scrollNavigationEnabled &&
                CONFIG.PRELOAD_ONLY_ADJACENT && typeof preloadAdjacentPages === 'function') {
                preloadAdjacentPages();
            }
            
            // Remove o overlay quando o iframe carregar
            var iframe = document.getElementById('iframeViewer');
            if (iframe) {
                var loadCount = 0;
                var maxRetries = 3;
                var retryDelay = 500; // 500ms entre tentativas
                var currentRetry = 0;
                var srcDefined = false; // Flag para rastrear se o src foi definido
                var timeoutId = null; // ID do timeout para poder cancelá-lo
                
                var loadHandler = function() {
                    loadCount++;
                    console.log('[goPagina] Iframe load event disparado (count:', loadCount, ', srcDefined:', srcDefined, '):', pdfjsViewerUrl);
                    
                    // Inicializa navegação por scroll quando o iframe carregar
                    if (srcDefined && loadCount === 1) {
                        setTimeout(function() {
                            // AJUSTA SCROLL BASEADO NA DIREÇÃO DA NAVEGAÇÃO (ANTES DE INICIALIZAR OUTRAS COISAS)
                            // Isso garante que a página seja aberta na posição correta (topo ou final)
                            // Esta é uma tentativa adicional caso o loadHandler não tenha conseguido ajustar
                            if (lastNavigationDirection && iframe && iframe.contentWindow) {
                                adjustScrollPosition(iframe.contentWindow, lastNavigationDirection);
                                // Reseta após um delay maior para garantir que todas as tentativas foram feitas
                                setTimeout(function() {
                                    lastNavigationDirection = null;
                                }, 3000);
                            }
                            
                            initScrollNavigation();
                            
                            // Inicia monitoramento de visualização apenas se scroll navigation está habilitado E proteções estão habilitadas
                            if (CONFIG.SCROLL_NAVIGATION_ENABLED && scrollNavigationEnabled &&
                                (CONFIG.REQUIRE_MIN_VIEW_PERCENT || CONFIG.REQUIRE_MIN_PAGE_TIME)) {
                                if (pageViewTracker && (!pageViewTracker.pageStartTime)) {
                                    if (typeof resetPageViewTracking === 'function') {
                                        resetPageViewTracking();
                                    }
                                }
                                
                                // Inicia monitoramento se ainda não foi iniciado
                                if (typeof startPageViewMonitoring === 'function') {
                                    startPageViewMonitoring();
                                }
                            }
                            
                            // Pré-carrega páginas adjacentes após carregar (apenas se scroll navigation está habilitado)
                            if (CONFIG.SCROLL_NAVIGATION_ENABLED && scrollNavigationEnabled &&
                                CONFIG.PRELOAD_ONLY_ADJACENT && typeof preloadAdjacentPages === 'function') {
                                setTimeout(function() {
                                    preloadAdjacentPages();
                                }, 300); // Aguarda 300ms após carregar para pré-carregar
                            }
                        }, 500); // Aguarda 500ms para garantir que o PDF.js carregou
                    }
                    
                    // Ignora o primeiro load se o src ainda não foi definido
                    // Isso acontece quando limpamos o src (definindo src = '')
                    if (!srcDefined) {
                        console.log('[goPagina] Ignorando load antes de definir src');
                        return;
                    }
                    
                    // Cancela o timeout já que o iframe carregou
                    if (timeoutId !== null) {
                        clearTimeout(timeoutId);
                        timeoutId = null;
                    }
                    
                    // Verifica se o conteúdo foi carregado corretamente
                    try {
                        // Tenta acessar o conteúdo do iframe para verificar se carregou
                        var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                        var iframeWindow = iframe.contentWindow;
                        
                        if (iframeDoc && iframeDoc.readyState === 'complete') {
                            console.log('[goPagina] Iframe carregado com sucesso (PDF.js):', pdfjsViewerUrl);
                            
                            // Ajusta scroll baseado na direção da navegação
                            // Aguarda um pouco para garantir que o PDF.js carregou completamente
                            // NÃO reseta lastNavigationDirection aqui - será resetado dentro de adjustScrollPosition após sucesso
                            setTimeout(function() {
                                if (lastNavigationDirection) {
                                    adjustScrollPosition(iframeWindow, lastNavigationDirection);
                                    // Reseta após um delay maior para garantir que todas as tentativas foram feitas
                                    setTimeout(function() {
                                        lastNavigationDirection = null;
                                    }, 3000);
                                }
                            }, 800); // Aguarda 800ms para garantir que o PDF.js renderizou
                            
                            iframe.removeEventListener('load', loadHandler);
                            iframe.removeEventListener('error', errorHandler);
                            return;
                        }
                    } catch (e) {
                        // Erro de CORS ao acessar conteúdo do iframe é normal
                        console.log('[goPagina] Não foi possível verificar conteúdo do iframe (CORS normal):', e.message);
                        
                        // Mesmo com erro de CORS, tenta ajustar scroll (pode funcionar)
                        setTimeout(function() {
                            try {
                                if (lastNavigationDirection) {
                                    adjustScrollPosition(iframe.contentWindow, lastNavigationDirection);
                                    // Reseta após um delay maior para garantir que todas as tentativas foram feitas
                                    setTimeout(function() {
                                        lastNavigationDirection = null;
                                    }, 3000);
                                }
                            } catch (e2) {
                                if (CONFIG.DEBUG_MODE) {
                                    console.warn('[goPagina] Não foi possível ajustar scroll (CORS):', e2);
                                }
                            }
                        }, 1000); // Aguarda mais tempo para PDF.js renderizar quando há CORS
                    }
                    
                    // Se chegou aqui, assume que carregou (mesmo que não possa verificar devido a CORS)
                    console.log('[goPagina] Assumindo que iframe carregou (PDF.js):', pdfjsViewerUrl);
                    
                    // Tenta ajustar scroll mesmo sem poder verificar o conteúdo
                    setTimeout(function() {
                        try {
                            if (lastNavigationDirection) {
                                adjustScrollPosition(iframe.contentWindow, lastNavigationDirection);
                                // Reseta após um delay maior para garantir que todas as tentativas foram feitas
                                setTimeout(function() {
                                    lastNavigationDirection = null;
                                }, 3000);
                            }
                        } catch (e) {
                            if (CONFIG.DEBUG_MODE) {
                                console.warn('[goPagina] Não foi possível ajustar scroll:', e);
                            }
                        }
                    }, 1000);
                    
                    iframe.removeEventListener('load', loadHandler);
                    iframe.removeEventListener('error', errorHandler);
                };
                
                var errorHandler = function(e) {
                    // Cancela o timeout em caso de erro também
                    if (timeoutId !== null) {
                        clearTimeout(timeoutId);
                        timeoutId = null;
                    }
                    
                    console.error('[goPagina] Erro ao carregar iframe:', pdfjsViewerUrl, e);
                    currentRetry++;
                    
                    if (currentRetry < maxRetries) {
                        console.log('[goPagina] Tentando novamente (tentativa', currentRetry + 1, 'de', maxRetries, ') após', retryDelay, 'ms');
                        setTimeout(function() {
                            iframe.setAttribute('src', pdfjsViewerUrl);
                        }, retryDelay);
                        retryDelay *= 2; // Backoff exponencial
                    } else {
                        console.error('[goPagina] Máximo de tentativas atingido');
                        alert('Erro ao carregar a página após ' + maxRetries + ' tentativas. Tente novamente.');
                        iframe.removeEventListener('load', loadHandler);
                        iframe.removeEventListener('error', errorHandler);
                    }
                };
                
                // Remove listeners anteriores se existirem
                iframe.addEventListener('load', loadHandler);
                iframe.addEventListener('error', errorHandler);
                
                // Limpa o src anterior e reseta contadores
                loadCount = 0;
                currentRetry = 0;
                retryDelay = 500;
                srcDefined = false; // Reseta flag
                iframe.setAttribute('src', '');
                
                // Aguarda um pouco antes de definir o novo src para garantir que o load do src vazio seja processado
                setTimeout(function() {
                    console.log('[goPagina] Definindo src do iframe (PDF.js):', pdfjsViewerUrl);
                    srcDefined = true; // Marca que o src foi definido
                    iframe.setAttribute('src', pdfjsViewerUrl);
                    
                    // Timeout de segurança: log após 15 segundos (será cancelado se iframe carregar antes)
                    timeoutId = setTimeout(function() {
                        console.warn('[goPagina] Timeout ao carregar página após 15 segundos');
                    }, 15000);
                }, 100);
            }
            } catch (error) {
                console.error('[goPagina] Erro:', error);
                showToast('error', 'Erro', 'Não foi possível carregar a página', 3000);
            }
        }
        
        // Função para atualizar interface
        function updateInterface(data) {
            // Atualiza header
            if (data.materia) {
                var titulo = data.materia.titulo || 'Matéria ' + data.cod_materia;
                document.getElementById('materia-titulo').textContent = titulo;
                document.getElementById('materia-codigo').textContent = 'Código: ' + data.cod_materia;
                
                // Atualiza breadcrumbs
                updateBreadcrumbs(data.materia);
                document.getElementById('page-title').textContent = 'Pasta Digital - ' + titulo;
            }
            
            var pasta = data.pasta || {};
            
            // CRÍTICO: Log detalhado para debug
            var hasDocuments = pasta.documentos && pasta.documentos.length > 0;
            var isAsync = pasta.async === true;
            var hasTaskId = pasta.task_id && pasta.task_id !== null && pasta.task_id !== '';
            console.log('[updateInterface] Estado atual:', {
                processamentoConcluido: processamentoConcluido,
                hasDocuments: hasDocuments,
                documentosCount: pasta.documentos ? pasta.documentos.length : 0,
                isAsync: isAsync,
                hasTaskId: hasTaskId,
                task_id: pasta.task_id,
                status: pasta.status
            });
            
            // CRÍTICO: Se tem documentos E processamento foi concluído, mostra documentos diretamente
            if (hasDocuments && processamentoConcluido) {
                console.log('[updateInterface] Processamento concluído e documentos disponíveis, mostrando diretamente');
                document.getElementById('loading-state').style.display = 'none';
                document.getElementById('async-monitor').style.display = 'none';
                stopDownloadButtonCheck(); // Para verificação periódica
                enableToolbarControls(); // Reabilita controles
                // Atualiza sidebar ANTES de mostrar documentos
                var sidebarData = {
                    materias_relacionadas: data.materias_relacionadas || {},
                    documentos_administrativos: data.documentos_administrativos || [],
                    normas_juridicas: data.normas_juridicas || [],
                    portal_url: data.portal_url || (typeof APP_DATA !== 'undefined' && APP_DATA.portal_url) || (window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/'))
                };
                updateSidebar(sidebarData);
                showDocumentos(pasta);
                return;
            }
            
            // CRÍTICO: Se tem documentos E não é async, mostra mensagem de carregamento e depois documentos
            // Pula o monitor quando documentos já estão prontos
            if (hasDocuments && !isAsync) {
                console.log('[updateInterface] Documentos disponíveis e não é async, mostrando mensagem de carregamento e depois documentos');
                // Mostra mensagem de carregamento brevemente
                var loadingState = document.getElementById('loading-state');
                if (loadingState) {
                    loadingState.style.display = 'flex';
                    // Atualiza mensagem se disponível
                    var loadingText = loadingState.querySelector('.progress-card p.text-muted');
                    if (loadingText) {
                        loadingText.textContent = pasta.message || 'Carregando documentos...';
                    }
                }
                document.getElementById('async-monitor').style.display = 'none';
                stopDownloadButtonCheck(); // Para verificação periódica
                
                // Após breve delay, esconde carregamento e mostra documentos
                setTimeout(function() {
                    if (loadingState) {
                        loadingState.style.display = 'none';
                    }
                    enableToolbarControls(); // Reabilita controles
                    // Atualiza sidebar ANTES de mostrar documentos
                    var sidebarData = {
                        materias_relacionadas: data.materias_relacionadas || {},
                        documentos_administrativos: data.documentos_administrativos || [],
                        normas_juridicas: data.normas_juridicas || [],
                        portal_url: data.portal_url || (typeof APP_DATA !== 'undefined' && APP_DATA.portal_url) || (window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/'))
                    };
                    updateSidebar(sidebarData);
                    showDocumentos(pasta);
                }, 500); // 500ms para mostrar mensagem de carregamento
                return; // CRÍTICO: Retorna aqui para evitar verificação adicional que pode iniciar polls
            }
            
            // CRÍTICO: Se tem documentos E async=true com status=SUCCESS, mostra monitor brevemente
            // Isso permite feedback visual mesmo quando documentos já estão prontos
            if (hasDocuments && isAsync && pasta.status === 'SUCCESS') {
                console.log('[updateInterface] Documentos disponíveis mas async=true com SUCCESS, mostrando monitor brevemente');
                document.getElementById('loading-state').style.display = 'none';
                showAsyncMonitor({
                    task_id: pasta.task_id || null,
                    status: 'SUCCESS',
                    async: true,
                    message: pasta.message || 'Pasta digital carregada com sucesso'
                });
                // Após 2 segundos, esconde monitor e mostra documentos
                setTimeout(function() {
                    document.getElementById('async-monitor').style.display = 'none';
                    stopDownloadButtonCheck();
                    enableToolbarControls();
                    // Atualiza sidebar ANTES de mostrar documentos
                    var sidebarData = {
                        materias_relacionadas: data.materias_relacionadas || {},
                        documentos_administrativos: data.documentos_administrativos || [],
                        normas_juridicas: data.normas_juridicas || [],
                        portal_url: data.portal_url || (typeof APP_DATA !== 'undefined' && APP_DATA.portal_url) || (window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/'))
                    };
                    updateSidebar(sidebarData);
                    showDocumentos(pasta);
                }, 2000);
                return;
            }
            
            // Se precisa gerar E tem task_id, mostra monitor diretamente em vez de loading
            var needsGeneration = !hasDocuments || (isAsync && hasTaskId);
            if (needsGeneration && hasTaskId) {
                console.log('[updateInterface] Processo precisa ser gerado, mostrando monitor diretamente');
                document.getElementById('loading-state').style.display = 'none';
                showAsyncMonitor({
                    task_id: pasta.task_id,
                    status: pasta.status || 'PENDING',
                    async: true
                });
                // CRÍTICO: Inicia polling de status quando há task_id
                var portalUrl = data.portal_url || APP_DATA.portal_url || '';
                if (portalUrl) {
                    startStatusPolling(pasta.task_id, portalUrl);
                }
                return; // Retorna para evitar verificação adicional
            } else if (hasDocuments) {
                // Tem documentos mas precisa verificar - mostra documentos diretamente
                console.log('[updateInterface] Documentos disponíveis, mostrando diretamente (fallback)');
                document.getElementById('loading-state').style.display = 'none';
                document.getElementById('async-monitor').style.display = 'none';
                stopDownloadButtonCheck(); // Para verificação periódica
                enableToolbarControls(); // Reabilita controles
                // Atualiza sidebar ANTES de mostrar documentos
                var sidebarData = {
                    materias_relacionadas: data.materias_relacionadas || {},
                    documentos_administrativos: data.documentos_administrativos || [],
                    normas_juridicas: data.normas_juridicas || [],
                    portal_url: data.portal_url || (typeof APP_DATA !== 'undefined' && APP_DATA.portal_url) || (window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/'))
                };
                updateSidebar(sidebarData);
                showDocumentos(pasta);
                return; // CRÍTICO: Retorna aqui para evitar verificação adicional que pode iniciar polls
            }
            
            // Verifica se é modo assíncrono (apenas se needsGeneration for true)
            // IMPORTANTE: Sempre verifica se há uma task ativa (task_id presente)
            // Se async: true mas sem task_id, significa que está completo
            var hasActiveTask = pasta.async && pasta.task_id;
            
            // IMPORTANTE: Se async: true mas sem task_id, verifica se há uma task ativa
            // Isso garante que o monitor apareça mesmo quando o backend não retornou task_id
            if (pasta.async && !pasta.task_id) {
                console.log('[updateInterface] async: true mas sem task_id, verificando se há task ativa...');
                // Monitor já foi mostrado acima, apenas atualiza status
                var monitorStatus = document.getElementById('monitor-status');
                if (monitorStatus) {
                    monitorStatus.textContent = 'Verificando status...';
                }
                // Faz uma chamada para verificar se há task ativa
                var portalUrl = data.portal_url || APP_DATA.portal_url || '';
                var baseUrl = portalUrl;
                if (baseUrl.includes('/consultas/materia')) {
                    baseUrl = baseUrl.replace('/consultas/materia', '');
                }
                baseUrl = baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;
                var checkUrl = baseUrl + '/@@pasta_digital_data?cod_materia=' + encodeURIComponent(data.cod_materia) + '&action=pasta';
                fetch(checkUrl)
                    .then(function(response) { return response.json(); })
                    .then(function(checkData) {
                        if (checkData.pasta && checkData.pasta.task_id) {
                            // Encontrou uma task ativa, inicia o polling
                            console.log('[updateInterface] Task ativa encontrada:', checkData.pasta.task_id);
                            showAsyncMonitor(checkData.pasta);
                            startStatusPolling(checkData.pasta.task_id, data.portal_url);
                        } else if (checkData.pasta && checkData.pasta.documentos && checkData.pasta.documentos.length > 0) {
                            // Não há task ativa mas há documentos, verifica se todos estão disponíveis
                            console.log('[updateInterface] Task concluída, verificando disponibilidade dos arquivos...');
                            // Mostra monitor enquanto verifica
                            showAsyncMonitor({
                                task_id: null,
                                status: 'Verificando disponibilidade dos arquivos...'
                            });
                            // Verifica se todos os arquivos estão disponíveis antes de mostrar
                            verifyAllPagesAvailable(checkData.pasta, baseUrl, data.cod_materia).then(function(allAvailable) {
                                if (allAvailable) {
                                    // Todos os arquivos disponíveis, mostra documentos
                                    console.log('[updateInterface] Todos os arquivos disponíveis, mostrando documentos');
                                    // Atualiza sidebar ANTES de mostrar documentos
                                    var sidebarData = {
                                        materias_relacionadas: data.materias_relacionadas || {},
                                        documentos_administrativos: data.documentos_administrativos || [],
                                        normas_juridicas: data.normas_juridicas || [],
                                        portal_url: data.portal_url || (typeof APP_DATA !== 'undefined' && APP_DATA.portal_url) || (window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/'))
                                    };
                                    updateSidebar(sidebarData);
                                    showDocumentos(checkData.pasta);
                                } else {
                                    // Se não estão disponíveis, mantém o monitor
                                    console.log('[updateInterface] Arquivos ainda não disponíveis, aguardando...');
                                    showAsyncMonitor({
                                        task_id: null,
                                    status: 'Aguardando disponibilidade dos arquivos...'
                                });
                                // NÃO faz nova chamada - aguarda polling da task
                                // O polling já está ativo e vai detectar quando os arquivos estiverem prontos
                                }
                            }).catch(function(error) {
                                console.error('[updateInterface] Erro ao verificar arquivos:', error);
                                // Em caso de erro, mostra os documentos mesmo assim
                                // Atualiza sidebar ANTES de mostrar documentos
                                var sidebarData = {
                                    materias_relacionadas: data.materias_relacionadas || {},
                                    documentos_administrativos: data.documentos_administrativos || [],
                                    normas_juridicas: data.normas_juridicas || [],
                                    portal_url: data.portal_url || (typeof APP_DATA !== 'undefined' && APP_DATA.portal_url) || (window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/'))
                                };
                                updateSidebar(sidebarData);
                                showDocumentos(checkData.pasta);
                            });
                        } else {
                            // Não há task ativa nem documentos, mostra monitor de espera
                            console.log('[updateInterface] Nenhuma task ativa encontrada, aguardando...');
                            showAsyncMonitor({
                                task_id: null,
                                status: 'Aguardando início da geração...'
                            });
                            // Tenta novamente após 2 segundos
                            setTimeout(function() {
                                loadPastaDigitalData();
                            }, 2000);
                        }
                    })
                    .catch(function(error) {
                        console.error('[updateInterface] Erro ao verificar task ativa:', error);
                        // Em caso de erro, se tem documentos, mostra eles; senão mostra monitor
                        if (pasta.documentos && pasta.documentos.length > 0) {
                            // Atualiza sidebar ANTES de mostrar documentos
                            var sidebarData = {
                                materias_relacionadas: data.materias_relacionadas || {},
                                documentos_administrativos: data.documentos_administrativos || [],
                                normas_juridicas: data.normas_juridicas || [],
                                portal_url: data.portal_url || (typeof APP_DATA !== 'undefined' && APP_DATA.portal_url) || (window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/'))
                            };
                            updateSidebar(sidebarData);
                            showDocumentos(pasta);
                        } else {
                            showAsyncMonitor({
                                task_id: null,
                                status: 'Erro ao verificar status...'
                            });
                        }
                    });
                return; // Para aqui, não continua para mostrar documentos diretamente
            }
            
            if (hasActiveTask) {
                // Limpa qualquer polling anterior antes de iniciar um novo
                if (pollInterval) {
                    clearTimeout(pollInterval);
                    pollInterval = null;
                }
                showAsyncMonitor(pasta);
                if (pasta.task_id) {
                    startStatusPolling(pasta.task_id, data.portal_url);
                }
            } else if (pasta.documentos && pasta.documentos.length > 0) {
                // Constrói baseUrl para verificação
                var portalUrl = data.portal_url || APP_DATA.portal_url || '';
                var baseUrl = portalUrl;
                if (baseUrl.includes('/consultas/materia')) {
                    baseUrl = baseUrl.replace('/consultas/materia', '');
                }
                baseUrl = baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;
                
                // Verifica se todos os arquivos estão disponíveis antes de mostrar
                verifyAllPagesAvailable(pasta, baseUrl, data.cod_materia).then(function(allAvailable) {
                    if (allAvailable) {
                        // Atualiza sidebar ANTES de mostrar documentos
                        var sidebarData = {
                            materias_relacionadas: data.materias_relacionadas || {},
                            documentos_administrativos: data.documentos_administrativos || [],
                            normas_juridicas: data.normas_juridicas || [],
                            portal_url: data.portal_url || (typeof APP_DATA !== 'undefined' && APP_DATA.portal_url) || (window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/'))
                        };
                        updateSidebar(sidebarData);
                        showDocumentos(pasta);
                    } else {
                        // Se não estão disponíveis, mostra monitor e tenta novamente
                        showAsyncMonitor({
                            task_id: null,
                            status: 'Verificando arquivos...'
                        });
                        document.getElementById('monitor-status').textContent = 'Verificando disponibilidade dos arquivos...';
                        // NÃO faz nova chamada - aguarda polling da task
                        // O polling já está ativo e vai detectar quando os arquivos estiverem prontos
                    }
                }).catch(function(error) {
                    console.error('Erro ao verificar arquivos:', error);
                    // Em caso de erro, mostra os documentos mesmo assim
                    // Atualiza sidebar ANTES de mostrar documentos
                    var sidebarData = {
                        materias_relacionadas: data.materias_relacionadas || {},
                        documentos_administrativos: data.documentos_administrativos || [],
                        normas_juridicas: data.normas_juridicas || [],
                        portal_url: data.portal_url || (typeof APP_DATA !== 'undefined' && APP_DATA.portal_url) || (window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/'))
                    };
                    updateSidebar(sidebarData);
                    showDocumentos(pasta);
                });
            } else if (pasta.error) {
                showError(pasta.error);
            } else {
                showError('Nenhum documento encontrado');
            }
            
            // Atualiza sidebar com informações relacionadas
            // Garante que portal_url está presente nos dados
            var sidebarData = {
                materias_relacionadas: data.materias_relacionadas || {},
                documentos_administrativos: data.documentos_administrativos || [],
                normas_juridicas: data.normas_juridicas || [],
                portal_url: data.portal_url || (typeof APP_DATA !== 'undefined' && APP_DATA.portal_url) || (window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/'))
            };
            
            console.log('[updateInterface] Chamando updateSidebar com dados:', sidebarData);
            updateSidebar(sidebarData);
        }
        
        /**
         * Mostra o botão de download APENAS quando o menu tem documentos renderizados
         * Esta função deve ser chamada APENAS após showDocumentos() ter renderizado os documentos
         * O botão já está com display:none por padrão no HTML
         */
        function showDownloadButton() {
            var downloadBtn = document.getElementById('btn-download');
            if (!downloadBtn) {
                return;
            }
            
            // PRIMEIRO: Verifica se o monitor está ativo - se estiver, NÃO mostra o botão
            var asyncMonitor = document.getElementById('async-monitor');
            if (asyncMonitor) {
                var computedStyle = window.getComputedStyle(asyncMonitor);
                if (computedStyle.display !== 'none') {
                    // Monitor está ativo, não mostra o botão (usa !important para garantir)
                    downloadBtn.style.setProperty('display', 'none', 'important');
                    return;
                }
            }
            
            // SEGUNDO: Verifica se o menu tem documentos renderizados
            var navList = document.getElementById('documentos-nav');
            var hasMenuItems = navList && navList.children.length > 0;
            
            // Só mostra o botão se o menu tiver itens renderizados E monitor não estiver ativo
            if (hasMenuItems) {
                var portalUrl = APP_DATA.portal_url || '';
                var codMateria = APP_DATA.cod_materia || '';
                if (portalUrl && codMateria) {
                    // Adiciona cache-busting para forçar navegador a baixar sem cache
                    var cacheBust = '&_t=' + Date.now();
                    downloadBtn.href = portalUrl + '/@@processo_leg_integral?cod_materia=' + 
                                      encodeURIComponent(codMateria) + '&action=download' + cacheBust;
                    // Usa setProperty com !important para sobrescrever o display:none !important do HTML
                    downloadBtn.style.setProperty('display', 'flex', 'important');
                } else {
                    downloadBtn.style.setProperty('display', 'none', 'important');
                }
            } else {
                downloadBtn.style.setProperty('display', 'none', 'important');
            }
        }
        
        /**
         * Reabilita os controles da toolbar após o monitor ser escondido
         */
        function enableToolbarControls() {
            var viewerControls = document.getElementById('viewer-controls');
            if (viewerControls) {
                // Remove classe de monitor ativo
                viewerControls.classList.remove('monitor-active');
                
                // Reabilita todos os botões
                var buttons = viewerControls.querySelectorAll('.btn');
                buttons.forEach(function(btn) {
                    btn.disabled = false;
                });
                
                // Reabilita input de página
                var pageInput = document.getElementById('page-input');
                if (pageInput) {
                    pageInput.disabled = false;
                }
            }
            
            // Botão de download permanece escondido até showDocumentos() renderizar os documentos
            // Não precisa fazer nada aqui - o botão já está com display:none por padrão
        }
        
        // Variável para armazenar o intervalo de verificação do botão
        var downloadButtonCheckInterval = null;
        
        /**
         * Para a verificação periódica do botão de download
         */
        function stopDownloadButtonCheck() {
            if (downloadButtonCheckInterval) {
                clearInterval(downloadButtonCheckInterval);
                downloadButtonCheckInterval = null;
            }
        }
        
        function showAsyncMonitor(pasta) {
            // Garante que o loading-state seja escondido PRIMEIRO
            var loadingState = document.getElementById('loading-state');
            if (loadingState) {
                loadingState.style.display = 'none';
            }
            
            // Mostra o monitor
            var asyncMonitor = document.getElementById('async-monitor');
            if (asyncMonitor) {
                asyncMonitor.style.display = 'flex';
            }
            
            // Botão de download já está escondido por padrão (display:none !important no HTML)
            // Força esconder novamente para garantir (usa !important)
            var downloadBtn = document.getElementById('btn-download');
            if (downloadBtn) {
                downloadBtn.style.setProperty('display', 'none', 'important');
            }
            
            // Inicia verificação periódica para garantir que o botão permaneça escondido
            stopDownloadButtonCheck(); // Limpa qualquer intervalo anterior
            downloadButtonCheckInterval = setInterval(function() {
                // Força esconder o botão enquanto monitor estiver ativo (usa !important)
                var downloadBtn = document.getElementById('btn-download');
                if (downloadBtn) {
                    downloadBtn.style.setProperty('display', 'none', 'important');
                }
            }, 500); // Verifica a cada 500ms enquanto o monitor estiver ativo
            
            // Desabilita controles do viewer com overlay
            var viewerControls = document.getElementById('viewer-controls');
            if (viewerControls) {
                // Adiciona classe para mostrar overlay e desabilitar
                viewerControls.classList.add('monitor-active');
                
                // Desabilita todos os botões
                var buttons = viewerControls.querySelectorAll('.btn');
                buttons.forEach(function(btn) {
                    btn.disabled = true;
                });
                
                // Desabilita input de página
                var pageInput = document.getElementById('page-input');
                if (pageInput) {
                    pageInput.disabled = true;
                }
            }
            
            // Inicializa o monitor com status padrão se não tiver informações
            if (!pasta || !pasta.status || pasta.status === 'PENDING') {
                var monitorStatus = document.getElementById('monitor-status');
                if (monitorStatus) {
                    monitorStatus.textContent = 'Iniciando geração...';
                }
                var progressBar = document.getElementById('progress-bar');
                if (progressBar) {
                    progressBar.style.width = '0%';
                    progressBar.setAttribute('aria-valuenow', 0);
                }
                var progressText = document.getElementById('progress-text');
                if (progressText) {
                    progressText.textContent = 'Aguardando início...';
                }
                var progressPercentage = document.getElementById('progress-percentage');
                if (progressPercentage) {
                    progressPercentage.textContent = '';
                }
                var stageIndicator = document.getElementById('stage-indicator');
                if (stageIndicator) {
                    stageIndicator.style.display = 'none';
                }
            } else if (pasta.status) {
                // Se tem status, atualiza
                var monitorStatus = document.getElementById('monitor-status');
                if (monitorStatus) {
                    // Usa status_text se disponível, senão usa message, senão usa status
                    monitorStatus.textContent = pasta.status_text || pasta.message || pasta.status || 'Processando...';
                }
                
                // Se status é SUCCESS, atualiza progresso para 100%
                if (pasta.status === 'SUCCESS') {
                    var progressBar = document.getElementById('progress-bar');
                    if (progressBar) {
                        progressBar.style.width = '100%';
                        progressBar.setAttribute('aria-valuenow', 100);
                    }
                    var progressText = document.getElementById('progress-text');
                    if (progressText) {
                        progressText.textContent = '100 de 100 concluído';
                    }
                    var progressPercentage = document.getElementById('progress-percentage');
                    if (progressPercentage) {
                        progressPercentage.textContent = ' (100%)';
                    }
                }
            }
        }
        
        // Função para verificar se todos os arquivos de página estão disponíveis
        async function verifyAllPagesAvailable(pasta, baseUrl, codMateria) {
            if (!pasta.documentos || !Array.isArray(pasta.documentos) || pasta.documentos.length === 0) {
                console.log('[verifyAllPagesAvailable] Sem documentos válidos:', {
                    hasDocumentos: !!pasta.documentos,
                    isArray: Array.isArray(pasta.documentos),
                    length: pasta.documentos ? pasta.documentos.length : 0
                });
                return false;
            }
            
            // Verifica algumas páginas chave (primeira, última, e algumas do meio)
            var totalPages = pasta.paginas_geral || 0;
            if (totalPages === 0) {
                console.log('[verifyAllPagesAvailable] Total de páginas é 0');
                // Se não tem paginas_geral mas tem documentos, assume que está OK
                // (pode ser que paginas_geral não esteja sendo retornado corretamente)
                if (pasta.documentos && pasta.documentos.length > 0) {
                    console.log('[verifyAllPagesAvailable] Total de páginas é 0 mas tem documentos, assumindo OK');
                    return true;
                }
                return false;
            }
            
            // Verifica primeira página, última página, e algumas do meio
            var pagesToCheck = [1];
            if (totalPages > 1) {
                pagesToCheck.push(totalPages);
            }
            if (totalPages > 2) {
                pagesToCheck.push(Math.floor(totalPages / 2));
            }
            if (totalPages > 3) {
                pagesToCheck.push(Math.floor(totalPages / 4));
                pagesToCheck.push(Math.floor(totalPages * 3 / 4));
            }
            
            // Remove duplicatas
            pagesToCheck = [...new Set(pagesToCheck)];
            
            console.log('[verifyAllPagesAvailable] Verificando páginas:', pagesToCheck);
            
            var checkPromises = pagesToCheck.map(function(pageNum) {
                var paginaFormatada = 'pg_' + String(pageNum).padStart(4, '0') + '.pdf';
                var pageUrl = baseUrl + '/@@pagina_processo_leg_integral?cod_materia=' + encodeURIComponent(codMateria) + '&pagina=' + encodeURIComponent(paginaFormatada) + '&_t=' + Date.now();
                
                // Usa GET em vez de HEAD para garantir que o arquivo realmente existe e está acessível
                // Alguns servidores podem retornar 200 no HEAD mas 404 no GET
                return fetch(pageUrl, { method: 'GET', cache: 'no-store' })
                    .then(function(response) {
                        var isAvailable = response.ok && response.status === 200;
                        // Verifica se o Content-Type é PDF
                        var contentType = response.headers.get('Content-Type') || '';
                        var isPDF = contentType.includes('application/pdf') || contentType.includes('pdf');
                        var finalAvailable = isAvailable && isPDF;
                        console.log('[verifyAllPagesAvailable] Página', pageNum, 'disponível?', finalAvailable, 'status:', response.status, 'content-type:', contentType);
                        // Consome a resposta para evitar warnings
                        if (response.body) {
                            response.body.cancel();
                        }
                        return finalAvailable;
                    })
                    .catch(function(error) {
                        console.log('[verifyAllPagesAvailable] Erro ao verificar página', pageNum, ':', error);
                        return false;
                    });
            });
            
            var results = await Promise.all(checkPromises);
            var allAvailable = results.every(function(result) { return result === true; });
            
            console.log('[verifyAllPagesAvailable] Todas as páginas verificadas disponíveis?', allAvailable);
            return allAvailable;
        }
        
        // Função para adicionar botão de download ao documento
        function addDownloadButtonToDocument(docItem, doc) {
            // Verifica se documento tem arquivo (processo_adm usa 'file')
            var filename = doc.file || doc.id;
            console.log('[addDownloadButtonToDocument] Verificando documento:', {
                title: doc.title,
                file: doc.file,
                id: doc.id,
                filename: filename,
                docKeys: Object.keys(doc)
            });
            
            if (!filename) {
                console.warn('[addDownloadButtonToDocument] Documento sem arquivo:', doc.title, 'doc completo:', doc);
                return; // Documentos sem arquivo não têm download
            }
            
            var downloadBtn = document.createElement('button');
            downloadBtn.className = 'doc-download-btn';
            downloadBtn.setAttribute('data-file', filename);
            downloadBtn.setAttribute('data-title', doc.title || 'Documento');
            downloadBtn.setAttribute('aria-label', 'Baixar ' + (doc.title || 'documento'));
            downloadBtn.innerHTML = '<i class="mdi mdi-download" aria-hidden="true"></i>';
            
            // Handler de clique
            downloadBtn.onclick = function(e) {
                e.preventDefault();
                e.stopPropagation(); // Evita que clique propague para o doc-item
                
                var filenameAttr = this.getAttribute('data-file');
                var title = this.getAttribute('data-title');
                
                downloadDocument(filenameAttr, title, doc);
            };
            
            // Insere botão no doc-item-content (entre título e badge)
            var docContent = docItem.querySelector('.doc-item-content');
            if (docContent) {
                console.log('[addDownloadButtonToDocument] docContent encontrado, inserindo botão. docContent HTML:', docContent.innerHTML.substring(0, 100));
                // Adiciona botão antes do badge se existir, senão no final
                var badge = docContent.querySelector('.doc-item-badge');
                if (badge) {
                    console.log('[addDownloadButtonToDocument] Badge encontrado, inserindo antes do badge');
                    docContent.insertBefore(downloadBtn, badge);
                } else {
                    console.log('[addDownloadButtonToDocument] Sem badge, adicionando no final do docContent');
                    docContent.appendChild(downloadBtn);
                }
                console.log('[addDownloadButtonToDocument] Botão inserido. docContent HTML final:', docContent.innerHTML.substring(0, 150));
                // Verifica se o botão realmente está no DOM
                var insertedBtn = docContent.querySelector('.doc-download-btn');
                if (insertedBtn) {
                    console.log('[addDownloadButtonToDocument] ✅ Botão confirmado no DOM');
                } else {
                    console.error('[addDownloadButtonToDocument] ❌ Botão NÃO encontrado no DOM após inserção!');
                }
            } else {
                console.warn('[addDownloadButtonToDocument] doc-content não encontrado, usando fallback. docItem HTML:', docItem.innerHTML.substring(0, 200));
                // Fallback: adiciona no final do doc-item
                docItem.appendChild(downloadBtn);
                console.log('[addDownloadButtonToDocument] Botão adicionado via fallback. docItem HTML final:', docItem.innerHTML.substring(0, 200));
            }
        }

        // Função para baixar documento
        function downloadDocument(filename, title, docData) {
            try {
                var portalUrl = APP_DATA.portal_url || '';
                
                // Detecta o tipo de processo baseado nos dados disponíveis
                var codMateria = APP_DATA.cod_materia || '';
                var codDocumento = APP_DATA.cod_documento || '';
                var codNorma = APP_DATA.cod_norma || '';
                var isNorma = APP_DATA.is_norma || false;
                var isAdm = APP_DATA.is_adm || false;
                
                var url = '';
                var codParam = '';
                
                // Determina endpoint e parâmetro baseado no tipo de processo
                if (codNorma || isNorma) {
                    // Processo Norma
                    codParam = codNorma;
                    if (!codParam) {
                        showToast('error', 'Erro', 'Dados insuficientes para download (cod_norma)', 3000);
                        return;
                    }
                    url = portalUrl + '/@@processo_norma_download_documento?cod_norma=' + 
                          encodeURIComponent(codParam) + 
                          '&file=' + encodeURIComponent(filename) +
                          '&title=' + encodeURIComponent(title || 'documento') +
                          '&_t=' + Date.now();
                } else if (codDocumento || isAdm) {
                    // Processo Administrativo
                    codParam = codDocumento;
                    if (!codParam) {
                        showToast('error', 'Erro', 'Dados insuficientes para download (cod_documento)', 3000);
                        return;
                    }
                    url = portalUrl + '/@@processo_adm_download_documento?cod_documento=' + 
                          encodeURIComponent(codParam) + 
                          '&file=' + encodeURIComponent(filename) +
                          '&title=' + encodeURIComponent(title || 'documento') +
                          '&_t=' + Date.now();
                } else if (codMateria) {
                    // Processo Legislativo (padrão)
                    codParam = codMateria;
                    url = portalUrl + '/@@processo_leg_download_documento?cod_materia=' + 
                          encodeURIComponent(codParam) + 
                          '&file=' + encodeURIComponent(filename) +
                          '&title=' + encodeURIComponent(title || 'documento') +
                          '&_t=' + Date.now();
                } else {
                    showToast('error', 'Erro', 'Dados insuficientes para download', 3000);
                    return;
                }
                
                if (!portalUrl || !codParam) {
                    showToast('error', 'Erro', 'Dados insuficientes para download', 3000);
                    return;
                }
                
                // Mostra feedback
                showToast('info', 'Baixando...', 'Preparando download de ' + title, 2000);
                
                // Cria link temporário e dispara download
                var link = document.createElement('a');
                link.href = url;
                
                // Nome do arquivo para download (sanitizado)
                var safeTitle = (title || 'documento').replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
                var extension = filename.match(/\.(pdf|doc|docx)$/i) ? filename.match(/\.(pdf|doc|docx)$/i)[0] : '.pdf';
                link.download = safeTitle + extension;
                
                link.style.display = 'none';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
            } catch (error) {
                console.error('[downloadDocument] Erro:', error);
                showToast('error', 'Erro', 'Não foi possível baixar o documento', 3000);
            }
        }
        
        function showDocumentos(pasta) {
            try {
                // Cache de elementos DOM para performance
                var asyncMonitor = document.getElementById('async-monitor');
                var loadingState = document.getElementById('loading-state');
                var viewerControls = document.getElementById('viewer-controls');
                var navList = document.getElementById('documentos-nav');
                var totalPagesEl = document.getElementById('total-pages');
                
                if (asyncMonitor) asyncMonitor.style.display = 'none';
                if (loadingState) loadingState.style.display = 'none';
                if (viewerControls) viewerControls.style.display = 'flex';
                
                // Para a verificação periódica do botão quando o monitor é escondido
                stopDownloadButtonCheck();
                
                enableToolbarControls(); // Reabilita controles
                
                // Botão de download já está escondido por padrão (display:none no HTML)
                // Será mostrado apenas após documentos renderizados
                
                var documentos = pasta.documentos || [];
                
                console.log('[showDocumentos] Iniciando renderização. Total de documentos:', documentos.length);
                console.log('[showDocumentos] Documentos recebidos:', documentos);
                // Debug: verifica campos 'file' nos documentos
                documentos.forEach(function(doc, idx) {
                    console.log('[showDocumentos] Documento ' + idx + ':', {
                        title: doc.title,
                        file: doc.file,
                        id: doc.id,
                        hasFile: !!(doc.file || doc.id),
                        keys: Object.keys(doc)
                    });
                });
                
                if (!navList) {
                    console.error('[showDocumentos] Elemento documentos-nav não encontrado');
                    return;
                }
                
                navList.innerHTML = '';
                navList.setAttribute('aria-label', 'Lista de documentos do processo');
                
                totalPages = pasta.paginas_geral || 0;
                if (totalPagesEl) {
                    totalPagesEl.textContent = totalPages;
                    totalPagesEl.setAttribute('aria-label', 'Total de ' + totalPages + ' páginas');
                }
                
                // Inicializa lista de documentos para navegação
                documentosList = [];
            
            documentos.forEach(function(doc, index) {
                // DEBUG: Log do documento no início do loop
                console.log('[showDocumentos] Processando documento', index, ':', {
                    title: doc.title,
                    file: doc.file,
                    id: doc.id,
                    hasFile: !!(doc.file || doc.id)
                });
                
                // Calcula start_page e end_page
                var startPage = 1;
                var endPage = 1;
                
                console.log('[showDocumentos] Processando documento', index, ':', doc.title);
                console.log('[showDocumentos] doc completo:', JSON.stringify(doc, null, 2));
                
                // Prioridade 1: Usa start_page e end_page se existirem diretamente no doc
                if (doc.start_page !== undefined && doc.start_page !== null) {
                    startPage = parseInt(doc.start_page);
                    endPage = parseInt(doc.end_page) || startPage;
                    console.log('[showDocumentos] Usando start_page/end_page do doc:', startPage, endPage);
                } 
                // Prioridade 2: Extrai do array paginas (método principal)
                else if (doc.paginas && doc.paginas.length > 0) {
                    var firstPagina = doc.paginas[0];
                    var lastPagina = doc.paginas[doc.paginas.length - 1];
                    
                    console.log('[showDocumentos] firstPagina:', firstPagina);
                    console.log('[showDocumentos] lastPagina:', lastPagina);
                    
                    // num_pagina vem como string do backend (ex: "1", "15", "23")
                    if (firstPagina.num_pagina !== undefined && firstPagina.num_pagina !== null && firstPagina.num_pagina !== '') {
                        startPage = parseInt(String(firstPagina.num_pagina).trim());
                        if (isNaN(startPage)) {
                            console.warn('[showDocumentos] num_pagina inválido:', firstPagina.num_pagina);
                            startPage = 1;
                        }
                    } else {
                        // Tenta extrair da URL se num_pagina não estiver disponível
                        if (firstPagina.url) {
                            var urlMatch = firstPagina.url.match(/pagina=pg_(\d+)\.pdf/);
                            if (urlMatch) {
                                startPage = parseInt(urlMatch[1]);
                                console.log('[showDocumentos] Extraído da URL:', startPage);
                            }
                        }
                    }
                    
                    if (lastPagina.num_pagina !== undefined && lastPagina.num_pagina !== null && lastPagina.num_pagina !== '') {
                        endPage = parseInt(String(lastPagina.num_pagina).trim());
                        if (isNaN(endPage)) {
                            console.warn('[showDocumentos] num_pagina inválido (last):', lastPagina.num_pagina);
                            endPage = startPage;
                        }
                    } else {
                        // Tenta extrair da URL se num_pagina não estiver disponível
                        if (lastPagina.url) {
                            var urlMatchLast = lastPagina.url.match(/pagina=pg_(\d+)\.pdf/);
                            if (urlMatchLast) {
                                endPage = parseInt(urlMatchLast[1]);
                                console.log('[showDocumentos] Extraído da URL (last):', endPage);
                            }
                        }
                    }
                    
                    console.log('[showDocumentos] Calculado do array paginas:', startPage, endPage);
                } 
                // Prioridade 3: Extrai de id_paginas
                else if (doc.id_paginas && doc.id_paginas.length > 0) {
                    var firstId = doc.id_paginas[0];
                    var lastId = doc.id_paginas[doc.id_paginas.length - 1];
                    var matchFirst = firstId.match(/pg_(\d+)\.pdf/);
                    var matchLast = lastId.match(/pg_(\d+)\.pdf/);
                    if (matchFirst) startPage = parseInt(matchFirst[1]);
                    if (matchLast) endPage = parseInt(matchLast[1]);
                    console.log('[showDocumentos] Usando id_paginas:', startPage, endPage);
                }
                
                // Se ainda não conseguiu calcular e não é o primeiro documento, usa acumulação
                if (startPage === 1 && index > 0 && documentosList.length > 0) {
                    var lastDoc = documentosList[documentosList.length - 1];
                    startPage = lastDoc.pagina_final + 1;
                    // Calcula endPage baseado no número de páginas do documento atual
                    var numPages = doc.paginas ? doc.paginas.length : (doc.paginas_doc || 1);
                    endPage = startPage + numPages - 1;
                    console.log('[showDocumentos] Calculado por acumulação:', startPage, endPage, '(numPages:', numPages, ')');
                }
                
                console.log('[showDocumentos] Final - startPage:', startPage, 'endPage:', endPage);
                
                // Adiciona à lista de documentos para navegação
                documentosList.push({
                    titulo: doc.title || 'Documento ' + (index + 1),
                    pagina_inicial: startPage,
                    pagina_final: endPage,
                    index: index,
                    paginas: doc.paginas || [] // Guarda as páginas para uso posterior
                });
                
                // Item na sidebar - novo layout moderno com sub-itens de páginas
                // Captura os valores em variáveis locais para evitar problema de closure
                var docStartPage = startPage;
                var docIndex = index;
                var docTitle = doc.title || 'Documento ' + (index + 1);
                var docPages = doc.paginas || [];
                
                // Cria wrapper para documento e páginas
                var docWrapper = document.createElement('div');
                docWrapper.className = 'doc-wrapper';
                docWrapper.setAttribute('data-doc-index', docIndex);
                
                // Item principal do documento
                var docItem = document.createElement('a');
                docItem.href = '#';
                docItem.className = 'doc-item';
                docItem.setAttribute('data-pagina-geral', docStartPage);
                docItem.setAttribute('role', 'button');
                docItem.setAttribute('aria-label', 'Ir para ' + docTitle + ', folha ' + docStartPage);
                docItem.setAttribute('tabindex', '0');
                
                // Adiciona tooltip com data e horário do documento (se disponível)
                var docData = doc.data || '';
                var tooltipText = docTitle;
                if (docData) {
                    // Formata a data para exibição (converte de YYYY-MM-DD HH:MM:SS para formato mais legível)
                    var formattedDate = docData;
                    try {
                        // Tenta formatar a data se estiver no formato esperado
                        if (docData.match(/^\d{4}-\d{2}-\d{2}/)) {
                            var dateParts = docData.split(' ');
                            var datePart = dateParts[0]; // YYYY-MM-DD
                            var timePart = dateParts[1] || '00:00:00'; // HH:MM:SS
                            var dateObj = new Date(datePart + 'T' + timePart);
                            if (!isNaN(dateObj.getTime())) {
                                // Formato: DD/MM/YYYY HH:MM
                                var day = String(dateObj.getDate()).padStart(2, '0');
                                var month = String(dateObj.getMonth() + 1).padStart(2, '0');
                                var year = dateObj.getFullYear();
                                var hours = String(dateObj.getHours()).padStart(2, '0');
                                var minutes = String(dateObj.getMinutes()).padStart(2, '0');
                                formattedDate = day + '/' + month + '/' + year + ' ' + hours + ':' + minutes;
                            }
                        }
                    } catch (e) {
                        // Se houver erro na formatação, usa a data original
                        formattedDate = docData;
                    }
                    tooltipText = docTitle + '\nData: ' + formattedDate;
                }
                docItem.setAttribute('title', tooltipText);
                
                // Calcula quantidade de páginas
                var pageCount = 0;
                if (docPages && docPages.length > 0) {
                    pageCount = docPages.length;
                } else if (doc.paginas_doc) {
                    pageCount = parseInt(doc.paginas_doc) || 0;
                } else if (startPage && endPage) {
                    pageCount = endPage - startPage + 1;
                }
                
                // Monta HTML com badge de folhas e ícone de expansão
                var badgeHtml = '';
                if (pageCount > 0) {
                    var pageLabel = pageCount === 1 ? 'folha' : 'folhas';
                    badgeHtml = '<span class="doc-item-badge" title="' + pageCount + ' ' + pageLabel + '">' + pageCount + ' fl</span>';
                }
                
                // Ícone de expansão/colapso (só mostra se houver folhas)
                var expandIconHtml = '';
                if (pageCount > 0) {
                    expandIconHtml = '<i class="mdi mdi-chevron-right doc-expand-icon" aria-hidden="true"></i>';
                }
                
                docItem.innerHTML = '<i class="mdi mdi-file-pdf-box text-danger" aria-hidden="true"></i>' +
                    expandIconHtml +
                    '<div class="doc-item-content">' +
                        '<span class="doc-item-title">' + docTitle + '</span>' +
                        badgeHtml +
                    '</div>';
                
                // NOVO: Adiciona botão de download ANTES de adicionar ao wrapper (para garantir que está no DOM)
                console.log('[showDocumentos] 🔍 VERIFICANDO download - docTitle:', docTitle, 'doc.file:', doc.file, 'doc.id:', doc.id, 'doc.file type:', typeof doc.file, 'doc.id type:', typeof doc.id);
                var hasFile = !!(doc.file || doc.id);
                console.log('[showDocumentos] hasFile:', hasFile);
                
                if (hasFile) {
                    console.log('[showDocumentos] ✅ ADICIONANDO botão de download para:', docTitle, 'arquivo:', doc.file || doc.id);
                    addDownloadButtonToDocument(docItem, doc);
                } else {
                    console.warn('[showDocumentos] ❌ Documento SEM arquivo - não adicionando botão:', docTitle, 'doc completo:', JSON.stringify(doc));
                }
                
                // Container de páginas (sub-itens)
                var docPagesContainer = document.createElement('div');
                docPagesContainer.className = 'doc-pages';
                
                // Adiciona links para cada página do documento
                if (docPages && docPages.length > 0) {
                    docPages.forEach(function(pag) {
                        var pageNum = parseInt(pag.num_pagina);
                        if (isNaN(pageNum)) {
                            // Tenta extrair da URL se num_pagina não estiver disponível
                            if (pag.url) {
                                var urlMatch = pag.url.match(/pagina=pg_(\d+)\.pdf/);
                                if (urlMatch) {
                                    pageNum = parseInt(urlMatch[1]);
                                }
                            }
                        }
                        
                        if (!isNaN(pageNum) && pag.url) {
                            var pageItem = document.createElement('a');
                            pageItem.href = '#';
                            pageItem.className = 'doc-page-item';
                            pageItem.setAttribute('data-pagina-geral', pageNum);
                            pageItem.setAttribute('role', 'button');
                            pageItem.setAttribute('aria-label', 'Ir para folha ' + pageNum);
                            pageItem.setAttribute('tabindex', '0');
                            pageItem.innerHTML = '<i class="mdi mdi-file-document-outline" aria-hidden="true"></i><span>Folha ' + pageNum + '</span>';
                            
                            // Handler de clique na página
                            pageItem.onclick = function(e) {
                                e.preventDefault();
                                e.stopPropagation(); // Evita que o clique propague para o documento pai
                                
                                // Remove active de todos os itens de página
                                var allPageItems = docPagesContainer.querySelectorAll('.doc-page-item');
                                for (var i = 0; i < allPageItems.length; i++) {
                                    allPageItems[i].classList.remove('active');
                                }
                                
                                // Adiciona active ao item clicado
                                pageItem.classList.add('active');
                                
                                // Navega para a página
                                goToPage(pageNum);
                            };
                            
                            // Suporte para navegação por teclado
                            pageItem.onkeydown = function(e) {
                                if (e.key === 'Enter' || e.key === ' ') {
                                    e.preventDefault();
                                    pageItem.onclick(e);
                                }
                            };
                            
                            docPagesContainer.appendChild(pageItem);
                        }
                    });
                }
                
                // Função para alternar expansão/colapso
                var toggleExpand = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    // Colapsa todos os outros documentos antes de expandir
                    if (!docWrapper.classList.contains('expanded')) {
                        collapseAllDocumentsExcept(docWrapper);
                    }
                    // Alterna o estado do documento atual
                    docWrapper.classList.toggle('expanded');
                };
                
                // Handler de clique com tratamento de erro
                var clickHandler = function(e) {
                    try {
                        // Se clicou no ícone de expansão, apenas expande/colapsa
                        if (e.target && e.target.classList.contains('doc-expand-icon')) {
                            toggleExpand(e);
                            return;
                        }
                        // Se clicou no pai do ícone (span ou i), também expande/colapsa
                        if (e.target && (e.target.closest('.doc-expand-icon') || e.target.parentElement && e.target.parentElement.classList.contains('doc-expand-icon'))) {
                            toggleExpand(e);
                            return;
                        }
                        
                        e.preventDefault();
                        console.log('[showDocumentos] Clicou no documento:', docTitle, 'página inicial:', docStartPage, 'índice:', docIndex);
                        
                        // Remove active de todos os wrappers e itens, e colapsa todos os documentos
                        var allWrappers = navList.querySelectorAll('.doc-wrapper');
                        for (var i = 0; i < allWrappers.length; i++) {
                            allWrappers[i].classList.remove('active');
                            allWrappers[i].classList.remove('expanded'); // Colapsa todos
                            var items = allWrappers[i].querySelectorAll('.doc-item');
                            for (var j = 0; j < items.length; j++) {
                                items[j].classList.remove('active');
                                items[j].setAttribute('aria-current', 'false');
                            }
                        }
                        
                        // Adiciona active ao wrapper e item clicado (expande automaticamente)
                        docWrapper.classList.add('active');
                        docWrapper.classList.add('expanded'); // Expande quando ativo
                        docItem.classList.add('active');
                        docItem.setAttribute('aria-current', 'true');
                        
                        // Scroll automático para o item clicado
                        setTimeout(function() {
                            scrollToActiveDocument();
                        }, 100);
                        
                        // Atualiza valores antes de chamar goPagina
                        var pageInput = document.getElementById('page-input');
                        if (pageInput) {
                            pageInput.value = docStartPage;
                        }
                        currentPage = docStartPage;
                        currentDocumentoIndex = docIndex;
                        updateDocumentNavigation();
                        
                        // Chama goPagina passando a página diretamente como parâmetro
                        goPagina(docStartPage);
                    } catch (error) {
                        console.error('[showDocumentos] Erro ao navegar para documento:', error);
                        showToast('error', 'Erro', 'Não foi possível abrir o documento ' + docTitle, 3000);
                    }
                };
                
                docItem.onclick = clickHandler;
                
                // Suporte para navegação por teclado (acessibilidade)
                docItem.onkeydown = function(e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        clickHandler(e);
                    }
                };
                
                // Adiciona elementos ao wrapper
                docWrapper.appendChild(docItem);
                docWrapper.appendChild(docPagesContainer);
                
                console.log('[showDocumentos] Adicionando item à navegação:', docTitle, 'índice:', index);
                navList.appendChild(docWrapper);
                console.log('[showDocumentos] Item adicionado. Total de filhos em navList:', navList.children.length);
            });
            
            console.log('[showDocumentos] Renderização concluída. Total de itens criados:', navList.children.length);
            console.log('[showDocumentos] Itens na navegação:', Array.from(navList.children).map(function(el) { return el.textContent.trim(); }));
            
                // Carrega primeira página
                if (documentos.length > 0) {
                    var firstDocStartPage = documentosList.length > 0 ? documentosList[0].pagina_inicial : 1;
                    var pageInput = document.getElementById('page-input');
                    if (pageInput) {
                        pageInput.value = firstDocStartPage;
                        pageInput.setAttribute('aria-valuenow', firstDocStartPage);
                    }
                    currentPage = firstDocStartPage;
                    currentDocumentoIndex = findCurrentDocumento(firstDocStartPage);
                    updateDocumentNavigation();
                    
                    // Ativa o primeiro item na sidebar (usando wrapper)
                    var firstWrapper = navList.querySelector('.doc-wrapper');
                    if (firstWrapper) {
                        collapseAllDocumentsExcept(firstWrapper); // Colapsa todos os outros
                        firstWrapper.classList.add('active');
                        firstWrapper.classList.add('expanded'); // Expande o primeiro documento
                        var firstItem = firstWrapper.querySelector('.doc-item');
                        if (firstItem) {
                            firstItem.classList.add('active');
                            firstItem.setAttribute('aria-current', 'true');
                        }
                        // Scroll automático para o primeiro item
                        setTimeout(function() {
                            scrollToActiveDocument();
                        }, 100);
                    }
                    
                    // Carrega a primeira página e inicializa navegação por scroll
                    goPagina(firstDocStartPage);
                    
                    // Inicializa navegação por scroll após carregar a primeira página (apenas se habilitado)
                    if (CONFIG.SCROLL_NAVIGATION_ENABLED) {
                        setTimeout(function() {
                            initScrollNavigation();
                            
                            // Inicia rastreamento de visualização apenas se scroll navigation está habilitado E proteções estão habilitadas
                            if (scrollNavigationEnabled && 
                                (CONFIG.REQUIRE_MIN_VIEW_PERCENT || CONFIG.REQUIRE_MIN_PAGE_TIME)) {
                                if (typeof resetPageViewTracking === 'function') {
                                    resetPageViewTracking();
                                }
                                // Inicia monitoramento se ainda não foi iniciado
                                if (typeof startPageViewMonitoring === 'function') {
                                    startPageViewMonitoring();
                                }
                            }
                            
                            // Pré-carrega páginas adjacentes apenas se scroll navigation está habilitado
                            if (scrollNavigationEnabled && CONFIG.PRELOAD_ONLY_ADJACENT && 
                                typeof preloadAdjacentPages === 'function') {
                                setTimeout(function() {
                                    preloadAdjacentPages();
                                }, 300);
                            }
                        }, 1500); // Aguarda 1.5s para garantir que o PDF.js carregou completamente
                    }
                    
                    // Mostra notificação de sucesso
                    showToast('success', 'Pasta Digital Carregada', 
                             documentos.length + ' documento(s) disponível(is) para visualização', 3000);
                }
                
                // Mostra botão de download APENAS após menu estar completamente renderizado
                // Usa setTimeout para garantir que o DOM foi completamente atualizado
                setTimeout(function() {
                    showDownloadButton();
                }, 500); // Delay para garantir que o DOM foi completamente atualizado e renderizado
            } catch (error) {
                console.error('[showDocumentos] Erro:', error);
                showToast('error', 'Erro', 'Não foi possível carregar a lista de documentos', 5000);
                if (loadingState) loadingState.style.display = 'none';
            }
        }
        
        function updateSidebar(data) {
            console.log('[updateSidebar] Chamada com dados:', {
                materias_relacionadas: data.materias_relacionadas,
                documentos_administrativos: data.documentos_administrativos,
                normas_juridicas: data.normas_juridicas,
                portal_url: data.portal_url
            });
            
            // Matérias relacionadas (anexadas/anexadoras)
            if (data.materias_relacionadas && data.materias_relacionadas.tem_relacionadas) {
                var section = document.getElementById('relacionadas-section');
                var nav = document.getElementById('relacionadas-nav');
                console.log('[updateSidebar] Matérias relacionadas encontradas:', {
                    tem_relacionadas: data.materias_relacionadas.tem_relacionadas,
                    anexadas: data.materias_relacionadas.anexadas,
                    anexadoras: data.materias_relacionadas.anexadoras,
                    section: section,
                    nav: nav
                });
                
                if (section && nav) {
                    section.style.display = 'block';
                    nav.innerHTML = '';
                    
                    var anexadas = data.materias_relacionadas.anexadas || [];
                    var anexadoras = data.materias_relacionadas.anexadoras || [];
                    
                    console.log('[updateSidebar] Adicionando matérias relacionadas:', anexadas.length + anexadoras.length);
                
                [...anexadas, ...anexadoras].forEach(function(m) {
                    var link = document.createElement('a');
                    // Matérias anexadas/anexadoras usam pasta_digital do legislativo
                    var portalUrl = data.portal_url || (typeof APP_DATA !== 'undefined' && APP_DATA.portal_url) || (window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/'));
                    link.href = portalUrl + '/@@pasta_digital?cod_materia=' + m.cod_materia + '&action=pasta';
                    link.className = 'doc-item';
                    link.innerHTML = '<i class="mdi mdi-link-variant text-primary"></i><span class="text-truncate">' + m.titulo + '</span>';
                    link.target = '_blank';
                    nav.appendChild(link);
                    console.log('[updateSidebar] Link de matéria adicionado:', m.titulo, 'URL:', link.href);
                });
                } else {
                    console.warn('[updateSidebar] Seção ou nav de matérias relacionadas não encontrado');
                }
            } else {
                console.log('[updateSidebar] Sem matérias relacionadas:', {
                    materias_relacionadas: data.materias_relacionadas,
                    tem_relacionadas: data.materias_relacionadas ? data.materias_relacionadas.tem_relacionadas : 'N/A'
                });
            }
            
            // Documentos administrativos
            if (data.documentos_administrativos && data.documentos_administrativos.length > 0) {
                var section = document.getElementById('documentos-adm-section');
                var nav = document.getElementById('documentos-adm-nav');
                if (section && nav) {
                    section.style.display = 'block';
                    nav.innerHTML = '';
                    
                    data.documentos_administrativos.forEach(function(doc) {
                        var link = document.createElement('a');
                        // Link para pasta digital do documento administrativo vinculado
                        var portalUrl = data.portal_url || (typeof APP_DATA !== 'undefined' && APP_DATA.portal_url) || (window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/'));
                        link.href = portalUrl + '/@@pasta_digital_adm?cod_documento=' + doc.cod_documento + '&action=pasta';
                        link.className = 'doc-item';
                        link.innerHTML = '<i class="mdi mdi-link-variant text-primary"></i><span class="text-truncate">' + doc.titulo + '</span>';
                        link.target = '_blank';
                        nav.appendChild(link);
                        console.log('[updateSidebar] Link de documento administrativo adicionado:', doc.titulo, 'URL:', link.href);
                    });
                } else {
                    console.warn('[updateSidebar] Seção ou nav de documentos administrativos não encontrado');
                }
            } else {
                console.log('[updateSidebar] Sem documentos administrativos:', {
                    documentos_administrativos: data.documentos_administrativos
                });
            }
            
            // Normas jurídicas (derivadas)
            if (data.normas_juridicas && data.normas_juridicas.length > 0) {
                var section = document.getElementById('normas-section');
                var nav = document.getElementById('normas-nav');
                console.log('[updateSidebar] Normas jurídicas encontradas:', {
                    count: data.normas_juridicas.length,
                    normas: data.normas_juridicas,
                    section: section,
                    nav: nav
                });
                
                if (section && nav) {
                    section.style.display = 'block';
                    nav.innerHTML = '';
                    
                    data.normas_juridicas.forEach(function(norma) {
                        var link = document.createElement('a');
                        // Link para pasta digital da norma derivada
                        var portalUrl = data.portal_url || (typeof APP_DATA !== 'undefined' && APP_DATA.portal_url) || (window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/'));
                        link.href = portalUrl + '/@@pasta_digital_norma?cod_norma=' + norma.cod_norma + '&action=pasta';
                        link.className = 'doc-item';
                        link.innerHTML = '<i class="mdi mdi-link-variant text-primary"></i><span class="text-truncate">' + norma.titulo + '</span>';
                        link.target = '_blank';
                        nav.appendChild(link);
                        console.log('[updateSidebar] Link de norma derivada adicionado:', norma.titulo, 'URL:', link.href);
                    });
                } else {
                    console.warn('[updateSidebar] Seção ou nav de normas jurídicas não encontrado');
                }
            } else {
                console.log('[updateSidebar] Sem normas jurídicas:', {
                    normas_juridicas: data.normas_juridicas
                });
            }
        }
        
        function showError(errorMsg) {
            document.getElementById('loading-state').style.display = 'none';
            document.getElementById('async-monitor').style.display = 'none';
            stopDownloadButtonCheck(); // Para verificação periódica
            document.getElementById('viewer-controls').style.display = 'none';
            document.getElementById('error-state').style.display = 'flex';
            document.getElementById('error-message').textContent = errorMsg;
        }
        
        // Polling de status assíncrono
        var pollInterval = null;
        var currentTaskId = null;
        var loadDocumentosLock = false; // Lock adicional para evitar múltiplas chamadas
        var loadDocumentosRetryCount = 0; // Contador de tentativas
        var loadDocumentosMaxRetries = 5; // Máximo de tentativas antes de desistir
        var processamentoConcluido = false; // Flag para evitar processamento duplicado de SUCCESS
        
        function startStatusPolling(taskId, portalUrl) {
            // CRÍTICO: Se processamento já foi concluído, não inicia novo polling
            if (processamentoConcluido) {
                console.log('[startStatusPolling] Processamento já concluído, não iniciando novo polling para task_id:', taskId);
                return;
            }
            
            // Evita iniciar múltiplos polling para o mesmo task_id
            if (currentTaskId === taskId && pollInterval) {
                console.log('[startStatusPolling] Polling já ativo para task_id:', taskId);
                return;
            }
            
            // Limpa qualquer polling anterior
            if (pollInterval) {
                clearTimeout(pollInterval);
                pollInterval = null;
            }
            
            // Reseta variáveis de progresso para nova task
            if (currentTaskId !== taskId) {
                progressStartTime = null;
                progressHistory = [];
                lastProgressUpdate = null;
            }
            
            currentTaskId = taskId;
            
            // Inicia o polling imediatamente (não espera o primeiro intervalo)
            // Isso garante que o status seja verificado logo após iniciar
            console.log('[startStatusPolling] Iniciando polling imediato para task_id:', taskId);
            checkStatusOnce();
            
            // Valida portalUrl antes de usar
            if (!portalUrl || portalUrl === '' || portalUrl === null || portalUrl === undefined) {
                console.error('startStatusPolling: portalUrl inválido:', portalUrl);
                // Tenta construir da URL atual
                try {
                    const urlObj = new URL(window.location.href);
                    const pathParts = urlObj.pathname.split('/').filter(p => p);
                    if (pathParts.length > 0) {
                        const lastPart = pathParts[pathParts.length - 1];
                        if (lastPart === 'pasta_digital' || lastPart === '@@pasta_digital') {
                            pathParts.pop();
                        }
                    }
                    portalUrl = urlObj.origin + '/' + pathParts.join('/');
                    console.log('startStatusPolling: portalUrl construído:', portalUrl);
                } catch (e) {
                    console.error('Erro ao construir portalUrl:', e);
                    const path = window.location.pathname;
                    portalUrl = window.location.origin + path.substring(0, path.lastIndexOf('/'));
                }
            }
            
            // Flag para indicar que polling deve parar
            var shouldStopPolling = false;
            
            // Função para verificar status uma vez
            function checkStatusOnce() {
                // CRÍTICO: Verifica se deve parar ou se ainda é a task atual antes de fazer requisição
                if (shouldStopPolling || processamentoConcluido || currentTaskId !== taskId || currentTaskId === null) {
                    console.log('[checkStatusOnce] Parando polling - shouldStopPolling:', shouldStopPolling, 'processamentoConcluido:', processamentoConcluido, 'currentTaskId:', currentTaskId, 'taskId:', taskId);
                    if (pollInterval) {
                        clearTimeout(pollInterval);
                        pollInterval = null;
                    }
                    return;
                }
                
                // Constrói URL correta: se portalUrl não termina com /, adiciona
                const baseUrl = portalUrl.endsWith('/') ? portalUrl.slice(0, -1) : portalUrl;
                const statusUrl = baseUrl + '/@@processo_leg_integral_status?task_id=' + encodeURIComponent(taskId);
                fetch(statusUrl)
                    .then(function(response) { 
                        if (!response.ok) {
                            throw new Error('HTTP ' + response.status);
                        }
                        return response.json(); 
                    })
                    .then(function(data) {
                        // Log apenas em modo debug (reduzido para melhor performance)
                        if (data.stage && window.DEBUG_MODE) {
                            console.log('[startStatusPolling] Fase:', data.stage, 'Progresso:', data.current, '/', data.total);
                        }
                        updateAsyncStatus(data);
                        
                        // Verifica se a task está concluída: ready === true OU status === 'SUCCESS'
                        // O backend pode retornar a mensagem em data.status, então verificamos data.ready também
                        var isSuccess = data.ready === true && (data.status === 'SUCCESS' || 
                                       (data.status && data.status.toLowerCase().includes('sucesso')));
                        var isFailure = data.ready === true && (data.status === 'FAILURE' || 
                                       (data.status && data.status.toLowerCase().includes('failure')) ||
                                       (data.error && data.error.length > 0));
                        
                        if (isFailure) {
                            // Para o polling imediatamente
                            shouldStopPolling = true;
                            if (pollInterval) {
                                clearTimeout(pollInterval);
                                pollInterval = null;
                            }
                            currentTaskId = null;
                            
                            // Mostra o erro no monitor
                            var errorMessage = data.error || data.message || 'Erro ao gerar processo';
                            showError(errorMessage);
                            
                            // Atualiza o status do monitor para mostrar o erro
                            var monitorStatus = document.getElementById('monitor-status');
                            if (monitorStatus) {
                                monitorStatus.textContent = 'Erro na geração do processo';
                            }
                            
                            // Atualiza a barra de progresso para mostrar erro
                            var progressBar = document.getElementById('progress-bar');
                            if (progressBar) {
                                progressBar.style.width = '0%';
                                progressBar.textContent = 'Erro';
                                progressBar.style.backgroundColor = '#dc3545';
                            }
                            
                            // NÃO chama loadDocumentosAfterSuccess quando há falha
                            return;
                        } else if (isSuccess) {
                            // CRÍTICO: Verifica se já processou o SUCCESS para evitar loop
                            if (processamentoConcluido) {
                                console.log('[checkStatusOnce] SUCCESS já foi processado, ignorando para evitar loop');
                                return;
                            }
                            
                            // Marca que o processamento foi concluído
                            processamentoConcluido = true;
                            
                            // CRÍTICO: Para o polling IMEDIATAMENTE quando task conclui
                            // Cancela TODOS os polls pendentes
                            shouldStopPolling = true;
                            if (pollInterval) {
                                clearTimeout(pollInterval);
                                pollInterval = null;
                            }
                            // Marca que a task foi concluída para evitar novos polls
                            currentTaskId = null;
                            
                            // Atualiza status para indicar que está verificando arquivos
                            var monitorStatus = document.getElementById('monitor-status');
                            if (monitorStatus) {
                                monitorStatus.textContent = 'Processo concluído. Verificando disponibilidade dos arquivos...';
                            }
                            
                            // Em vez de recarregar, busca os dados atualizados
                            // Evita múltiplas chamadas simultâneas (dupla verificação)
                            if (!loadingInProgress && !loadDocumentosLock) {
                                console.log('[checkStatusOnce] Chamando loadDocumentosAfterSuccess após SUCCESS (com delay de 500ms para dar tempo ao backend)');
                                // Adiciona um pequeno delay para dar tempo ao backend processar os documentos
                                setTimeout(function() {
                                    loadDocumentosAfterSuccess(portalUrl, APP_DATA.cod_materia);
                                }, 500);
                            } else {
                                console.log('[checkStatusOnce] loadDocumentosAfterSuccess já em progresso, ignorando');
                            }
                        }
                        // Se status é PENDING, PROGRESS ou STARTED, continua o polling
                    })
                    .catch(function(error) {
                        console.error('Erro ao verificar status:', error);
                        // Não para o polling em caso de erro de rede temporário
                    });
            }
            
            // OTIMIZADO: Polling adaptativo - mais frequente no início, menos quando em progresso
            // Intervalo inicial de 300ms para capturar início rápido, depois aumenta para 1000ms
            var pollCount = 0;
            var currentInterval = 300; // Inicia com 300ms
            
            function scheduleNextPoll() {
                pollCount++;
                // Primeiros 5 polls: 300ms (para capturar início rápido)
                // Depois: 1000ms (economiza recursos quando já está processando)
                if (pollCount <= 5) {
                    currentInterval = 300;
                } else {
                    currentInterval = 1000;
                }
                
                if (pollInterval) {
                    clearTimeout(pollInterval);
                }
                // CRÍTICO: Verifica se deve parar ou se ainda há task ativa antes de agendar próximo poll
                if (shouldStopPolling || processamentoConcluido) {
                    console.log('[scheduleNextPoll] Parando polling - shouldStopPolling:', shouldStopPolling, 'processamentoConcluido:', processamentoConcluido);
                    pollInterval = null;
                    return;
                }
                if (currentTaskId === taskId && currentTaskId !== null && !processamentoConcluido) {
                    pollInterval = setTimeout(function() {
                        // Verifica novamente se deve parar ou se ainda é a mesma task
                        if (shouldStopPolling || processamentoConcluido || currentTaskId !== taskId || currentTaskId === null) {
                            console.log('[scheduleNextPoll] Poll cancelado - shouldStopPolling:', shouldStopPolling, 'processamentoConcluido:', processamentoConcluido, 'currentTaskId:', currentTaskId, 'taskId:', taskId);
                            pollInterval = null;
                            return;
                        }
                        checkStatusOnce();
                        scheduleNextPoll();
                    }, currentInterval);
                } else {
                    // Task foi cancelada ou concluída, não agenda mais polls
                    pollInterval = null;
                }
            }
            
            // Inicia o polling adaptativo
            scheduleNextPoll();
        }
        
        // Função para carregar documentos após sucesso sem recarregar a página
        async function loadDocumentosAfterSuccess(portalUrl, codMateria) {
            // Evita múltiplas chamadas simultâneas (dupla verificação)
            if (loadingInProgress || loadDocumentosLock) {
                console.log('[loadDocumentosAfterSuccess] Carregamento já em progresso, ignorando (loadingInProgress:', loadingInProgress, ', lock:', loadDocumentosLock, ')');
                return;
            }
            
            loadingInProgress = true;
            loadDocumentosLock = true;
            
            try {
                // Valida portalUrl
                if (!portalUrl || portalUrl === '' || portalUrl === null || portalUrl === undefined) {
                    // Tenta construir da URL atual
                    try {
                        const urlObj = new URL(window.location.href);
                        const pathParts = urlObj.pathname.split('/').filter(p => p);
                        if (pathParts.length > 0) {
                            const lastPart = pathParts[pathParts.length - 1];
                            if (lastPart === 'pasta_digital' || lastPart === '@@pasta_digital') {
                                pathParts.pop();
                            }
                        }
                        portalUrl = urlObj.origin + '/' + pathParts.join('/');
                        console.log('[loadDocumentosAfterSuccess] portalUrl construído:', portalUrl);
                    } catch (e) {
                        console.error('Erro ao construir portalUrl:', e);
                        const path = window.location.pathname;
                        portalUrl = window.location.origin + path.substring(0, path.lastIndexOf('/'));
                    }
                }
                
                // Mostra loading
                document.getElementById('async-monitor').style.display = 'none';
                document.getElementById('loading-state').style.display = 'flex';
                
                // Constrói URL correta: usa o portal_url base (sem /consultas/materia)
                // A view @@pasta_digital_data está no contexto raiz do portal
                let baseUrl = portalUrl;
                if (baseUrl.includes('/consultas/materia')) {
                    // Remove /consultas/materia da URL
                    baseUrl = baseUrl.replace('/consultas/materia', '');
                }
                // Remove barra final se existir
                baseUrl = baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;
                const apiUrl = baseUrl + '/@@pasta_digital_data?cod_materia=' + encodeURIComponent(codMateria) + '&action=pasta';
                console.log('[loadDocumentosAfterSuccess] Fazendo fetch para:', apiUrl);
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    throw new Error('Erro HTTP: ' + response.status);
                }
                
                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.error || 'Erro ao carregar dados');
                }
                
                // Verifica se todos os arquivos de página estão disponíveis
                var pasta = data.pasta || {};
                
                // CRÍTICO: Log completo do que foi recebido do backend
                console.log('[loadDocumentosAfterSuccess] Dados recebidos do backend (completo):', {
                    data_keys: Object.keys(data),
                    pasta_type: typeof pasta,
                    pasta_keys: pasta ? Object.keys(pasta) : [],
                    pasta_documentos_type: typeof pasta.documentos,
                    pasta_documentos_isArray: Array.isArray(pasta.documentos),
                    pasta_documentos_length: pasta.documentos ? pasta.documentos.length : 'N/A',
                    pasta_documentos_value: pasta.documentos,
                    hasDocuments: pasta.documentos && pasta.documentos.length > 0,
                    documentosCount: pasta.documentos ? pasta.documentos.length : 0,
                    isAsync: pasta.async,
                    hasTaskId: pasta.task_id !== null && pasta.task_id !== '',
                    task_id: pasta.task_id,
                    status: pasta.status,
                    pasta_completo: JSON.stringify(pasta).substring(0, 500)
                });
                
                // CRÍTICO: Verifica se documentos são válidos, mas NÃO força async=false
                // O backend agora retorna async=true com status=SUCCESS para mostrar o monitor brevemente
                // Verifica também se documentos é um array válido e não está vazio
                var hasValidDocuments = pasta.documentos && 
                                       Array.isArray(pasta.documentos) && 
                                       pasta.documentos.length > 0;
                
                console.log('[loadDocumentosAfterSuccess] Verificação de documentos:', {
                    hasValidDocuments: hasValidDocuments,
                    pasta_documentos_exists: !!pasta.documentos,
                    isArray: Array.isArray(pasta.documentos),
                    length: pasta.documentos ? pasta.documentos.length : 0,
                    async: pasta.async,
                    status: pasta.status
                });
                
                if (hasValidDocuments) {
                    // CRÍTICO: Mantém async e status do backend para permitir que monitor apareça
                    // Se backend retornou async=true com status=SUCCESS, mantém para mostrar monitor brevemente
                    console.log('[loadDocumentosAfterSuccess] Documentos encontrados, mantendo async e status do backend:', {
                        async: pasta.async,
                        status: pasta.status,
                        task_id: pasta.task_id
                    });
                    // Não força async=false - permite que monitor apareça se backend retornou async=true
                    
                    // Verifica se todos os arquivos de página estão disponíveis
                    // Mas não bloqueia se a verificação falhar - pode ser problema de timing/rede
                    var allFilesAvailable = await verifyAllPagesAvailable(pasta, baseUrl, codMateria);
                    
                    if (!allFilesAvailable) {
                        console.log('[loadDocumentosAfterSuccess] Verificação de arquivos falhou, mas documentos existem. Tentando mostrar mesmo assim...');
                        // Se temos documentos válidos, tenta mostrar mesmo que a verificação tenha falhado
                        // A verificação pode falhar por problemas de rede ou timing, mas os arquivos podem estar OK
                        // Se realmente não estiverem disponíveis, o usuário verá erro ao tentar abrir
                        // Mas pelo menos tentamos mostrar a interface
                        console.log('[loadDocumentosAfterSuccess] Prosseguindo com exibição dos documentos apesar da verificação falhar');
                    } else {
                        console.log('[loadDocumentosAfterSuccess] Verificação de arquivos OK, todos disponíveis');
                    }
                } else {
                    // Não tem documentos ainda, mantém async se o backend retornou
                    console.log('[loadDocumentosAfterSuccess] Nenhum documento encontrado ainda', {
                        pasta_documentos: pasta.documentos,
                        pasta_documentos_type: typeof pasta.documentos,
                        isArray: Array.isArray(pasta.documentos),
                        length: pasta.documentos ? pasta.documentos.length : 'N/A'
                    });
                    
                    // Se não tem documentos mas também não tem task_id, pode ser que os documentos estejam prontos mas não foram detectados
                    // Tenta recarregar após um pequeno delay (com limite de tentativas)
                    if (!pasta.task_id && !pasta.async) {
                        if (loadDocumentosRetryCount < loadDocumentosMaxRetries) {
                            loadDocumentosRetryCount++;
                            var delay = 1000 * loadDocumentosRetryCount; // Aumenta o delay a cada tentativa
                            console.log('[loadDocumentosAfterSuccess] Sem documentos e sem task, tentativa ' + loadDocumentosRetryCount + '/' + loadDocumentosMaxRetries + ', aguardando ' + delay + 'ms...');
                            setTimeout(function() {
                                loadDocumentosLock = false;
                                loadDocumentosAfterSuccess(portalUrl, codMateria);
                            }, delay);
                            return;
                        } else {
                            console.log('[loadDocumentosAfterSuccess] Máximo de tentativas atingido, desistindo...');
                            loadDocumentosRetryCount = 0; // Reseta contador
                        }
                    } else {
                        // Se tem task_id ou async=true, reseta contador (não é problema de timing)
                        loadDocumentosRetryCount = 0;
                    }
                }
                
                // CRÍTICO: Atualiza APP_DATA.pasta para garantir que o estado global está correto
                APP_DATA.pasta = pasta;
                
                // CRÍTICO: Garante que não há mais task ativa
                currentTaskId = null;
                
                // CRÍTICO: Só mostra documentos se realmente houver documentos disponíveis
                // Usa a mesma verificação robusta
                var hasValidDocumentsFinal = pasta.documentos && 
                                            Array.isArray(pasta.documentos) && 
                                            pasta.documentos.length > 0;
                
                if (hasValidDocumentsFinal) {
                    // CRÍTICO: Esconde o monitor antes de mostrar documentos
                    document.getElementById('async-monitor').style.display = 'none';
                    document.getElementById('loading-state').style.display = 'none';
                    stopDownloadButtonCheck(); // Para verificação periódica
                    enableToolbarControls(); // Reabilita controles
                    
                    // CRÍTICO: Log detalhado antes de chamar updateInterface
                    console.log('[loadDocumentosAfterSuccess] Dados antes de updateInterface:', {
                        hasDocuments: true,
                        documentosCount: pasta.documentos.length,
                        isAsync: pasta.async,
                        hasTaskId: pasta.task_id !== null && pasta.task_id !== '',
                        task_id: pasta.task_id,
                        status: pasta.status,
                        pasta_keys: Object.keys(pasta)
                    });
                    
                    // CRÍTICO: Atualiza interface com os documentos - chama showDocumentos diretamente para garantir
                    console.log('[loadDocumentosAfterSuccess] Chamando showDocumentos diretamente com documentos prontos');
                    // Reseta contador de retry quando encontra documentos
                    loadDocumentosRetryCount = 0;
                    showDocumentos(pasta);
                    
                    // Também atualiza APP_DATA completo para garantir consistência
                    if (data.materia) APP_DATA.materia = data.materia;
                    if (data.portal_config) APP_DATA.portal_config = data.portal_config;
                    if (data.materias_relacionadas) APP_DATA.materias_relacionadas = data.materias_relacionadas;
                    if (data.documentos_administrativos) APP_DATA.documentos_administrativos = data.documentos_administrativos;
                    if (data.normas_juridicas) APP_DATA.normas_juridicas = data.normas_juridicas;
                    
                    // CRÍTICO: Atualiza sidebar com informações relacionadas após carregar documentos
                    // Garante que portal_url está presente nos dados
                    var sidebarData = {
                        materias_relacionadas: data.materias_relacionadas || APP_DATA.materias_relacionadas || {},
                        documentos_administrativos: data.documentos_administrativos || APP_DATA.documentos_administrativos || [],
                        normas_juridicas: data.normas_juridicas || APP_DATA.normas_juridicas || [],
                        portal_url: data.portal_url || APP_DATA.portal_url || window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/')
                    };
                    
                    console.log('[loadDocumentosAfterSuccess] Atualizando sidebar com dados:', sidebarData);
                    updateSidebar(sidebarData);
                    
                    // Atualiza header se necessário
                    if (data.materia) {
                        var titulo = data.materia.titulo || 'Matéria ' + codMateria;
                        var tituloEl = document.getElementById('materia-titulo');
                        var codigoEl = document.getElementById('materia-codigo');
                        if (tituloEl) tituloEl.textContent = titulo;
                        if (codigoEl) codigoEl.textContent = 'Código: ' + codMateria;
                    }
                } else {
                    // Não há documentos ainda, mantém monitor visível
                    console.log('[loadDocumentosAfterSuccess] Nenhum documento encontrado, mantendo monitor');
                    document.getElementById('async-monitor').style.display = 'block';
                    document.getElementById('loading-state').style.display = 'none';
                }
                
            } catch (error) {
                console.error('Erro ao carregar documentos após sucesso:', error);
                showError('Erro ao carregar documentos: ' + error.message);
            } finally {
                loadingInProgress = false;
                // Só libera o lock se não estiver em retry
                if (loadDocumentosRetryCount === 0) {
                    loadDocumentosLock = false;
                }
            }
        }
        
        function updateAsyncStatus(data) {
            // CRÍTICO: Se processamento já foi concluído, não atualiza status (evita loop)
            if (processamentoConcluido && (data.status === 'SUCCESS' || data.ready === true)) {
                console.log('[updateAsyncStatus] Processamento já concluído, ignorando atualização de status para evitar loop');
                return;
            }
            
            // Garante que o botão de download está escondido enquanto o monitor está ativo
            // Botão de download já está escondido por padrão (display:none !important no HTML)
            // Força esconder novamente para garantir (usa !important)
            var downloadBtn = document.getElementById('btn-download');
            if (downloadBtn) {
                downloadBtn.style.setProperty('display', 'none', 'important');
            }
            
            var progress = data.current || 0;
            var total = data.total || 100;
            var percent = total > 0 ? Math.round((progress / total) * 100) : 0;
            
            var progressBar = document.getElementById('progress-bar');
            var progressText = document.getElementById('progress-text');
            var statusText = document.getElementById('monitor-status');
            var stageIndicator = document.getElementById('stage-indicator');
            var stageText = document.getElementById('stage-text');
            var progressDetails = document.getElementById('progress-details');
            
            // Inicializa tempo de início se ainda não foi inicializado
            if (progressStartTime === null && progress > 0) {
                progressStartTime = Date.now();
            }
            
            // Atualiza histórico de progresso
            if (progress > 0) {
                progressHistory.push({
                    time: Date.now(),
                    progress: progress,
                    total: total
                });
                // Mantém apenas últimos 10 registros
                if (progressHistory.length > 10) {
                    progressHistory.shift();
                }
            }
            
            if (progressBar) {
                progressBar.style.width = percent + '%';
                progressBar.textContent = percent + '%';
                progressBar.setAttribute('aria-valuenow', percent);
            }
            
            if (progressText) {
                progressText.textContent = progress + ' de ' + total + ' concluído';
            }
            
            // Atualiza porcentagem numérica
            var progressPercentage = document.getElementById('progress-percentage');
            if (progressPercentage) {
                progressPercentage.textContent = percent > 0 ? ' (' + percent + '%)' : '';
            }
            
            if (statusText && data.status) {
                // Se tem mensagem de status específica, usa ela; senão usa mensagem padrão
                if (data.status && data.status !== 'PROGRESS' && data.status !== 'STARTED') {
                    var statusMessages = {
                        'PENDING': 'Aguardando início...',
                        'SUCCESS': 'Concluído!',
                        'FAILURE': 'Erro na geração'
                    };
                    statusText.textContent = statusMessages[data.status] || data.status;
                } else if (data.status_text || data.message) {
                    // Usa mensagem de status específica se disponível
                    statusText.textContent = data.status_text || data.message || 'Processando...';
                } else {
                    statusText.textContent = 'Processando...';
                }
            }
            
            // Mostra indicador de fase se disponível
            if (data.stage && stageIndicator && stageText) {
                stageIndicator.style.display = 'block';
                var stageMessages = {
                    'init': 'Inicializando',
                    'dados_materia': 'Obtendo dados da matéria',
                    'preparar_dirs': 'Preparando diretórios',
                    'coletar_docs': 'Coletando documentos',
                    'mesclar_docs': 'Mesclando documentos',
                    'salvar_paginas': 'Salvando páginas individuais',
                    'salvar_pdf': 'Salvando PDF final',
                    'limpar_temp': 'Limpando arquivos temporários',
                    'concluido': 'Finalizando',
                    'formatar': 'Formatando resultado',
                    'finalizar': 'Finalizando'
                };
                var stageTextContent = stageMessages[data.stage] || data.stage;
                stageText.textContent = stageTextContent;
                console.log('[updateAsyncStatus] Fase atual:', data.stage, '->', stageTextContent);
            } else if (stageIndicator) {
                // Esconde indicador se não há fase
                stageIndicator.style.display = 'none';
            }
            
            // Atualiza indicadores detalhados de progresso
            if (progressDetails && progress > 0 && total > 0) {
                progressDetails.style.display = 'flex';
                
                // Velocidade
                var speedEl = document.getElementById('progress-speed');
                if (speedEl) {
                    speedEl.textContent = calculateSpeed(progress, progressStartTime);
                }
                
                // Tempo restante (ETA)
                var etaEl = document.getElementById('progress-eta');
                if (etaEl) {
                    var eta = calculateETA(progress, total, progressStartTime);
                    etaEl.textContent = eta !== null ? formatTime(eta) : 'Calculando...';
                }
                
                // Tempo decorrido
                var elapsedEl = document.getElementById('progress-elapsed');
                if (elapsedEl && progressStartTime) {
                    elapsedEl.textContent = formatElapsedTime(progressStartTime);
                }
                
                // Itens processados
                var itemsEl = document.getElementById('progress-items');
                if (itemsEl) {
                    itemsEl.textContent = progress + ' / ' + total;
                }
            } else if (progressDetails) {
                progressDetails.style.display = 'none';
            }
            
            // Atualiza timeline de etapas se disponível
            if (data.stage && data.all_stages) {
                updateStagesTimeline(data.stage, data.all_stages);
            }
            
            // Log para debug
            console.log('[updateAsyncStatus] Status:', data.status, 'Progresso:', progress, '/', total, 'Fase:', data.stage || 'N/A', 'Status text:', data.status_text || data.message || 'N/A', 'Dados completos:', JSON.stringify(data, null, 2));
        }
        
        // Flag para evitar múltiplas inicializações
        var initialized = false;
        var loadingInProgress = false;
        
        // Função para carregar dados
        async function loadPastaDigitalData() {
            // Evita múltiplas inicializações
            if (initialized) {
                console.log('[loadPastaDigitalData] Já inicializado, ignorando');
                return;
            }
            
            // Evita múltiplas chamadas simultâneas
            if (loadingInProgress) {
                console.log('[loadPastaDigitalData] Carregamento já em progresso, ignorando');
                return;
            }
            
            loadingInProgress = true;
            
            // Verifica se os dados já foram injetados pelo servidor
            // Verifica se APP_DATA existe e tem pasta (mesmo que vazia, se foi injetado pelo servidor)
            var hasInjectedData = typeof APP_DATA !== 'undefined' && 
                                  APP_DATA !== null &&
                                  APP_DATA.pasta !== undefined &&
                                  APP_DATA.pasta !== null;
            
            // Log para debug - mostra o conteúdo completo de APP_DATA
            console.log('[loadPastaDigitalData] Verificando hasInjectedData:', {
                hasAPP_DATA: typeof APP_DATA !== 'undefined',
                APP_DATA_not_null: APP_DATA !== null,
                pasta_defined: APP_DATA && APP_DATA.pasta !== undefined,
                pasta_not_null: APP_DATA && APP_DATA.pasta !== null,
                pasta_keys: APP_DATA && APP_DATA.pasta ? Object.keys(APP_DATA.pasta) : null,
                pasta_async: APP_DATA && APP_DATA.pasta ? APP_DATA.pasta.async : null,
                pasta_task_id: APP_DATA && APP_DATA.pasta ? APP_DATA.pasta.task_id : null,
                hasInjectedData: hasInjectedData,
                cod_materia: APP_DATA.cod_materia,
                portal_url: APP_DATA.portal_url
            });
            // Log completo do APP_DATA em uma linha separada para facilitar debug
            console.log('[loadPastaDigitalData] APP_DATA completo:', APP_DATA);
            console.log('[loadPastaDigitalData] APP_DATA.pasta:', APP_DATA.pasta);
            
            // Tenta completar dados faltantes da URL ou valores padrão
            // SEMPRE completa, mesmo que os valores já existam (garante que não sejam null/undefined)
            const urlParams = new URLSearchParams(window.location.search);
            
            // Completa cod_materia da URL se estiver faltando ou vazio
            if (!APP_DATA.cod_materia || APP_DATA.cod_materia === '' || APP_DATA.cod_materia === null || APP_DATA.cod_materia === undefined) {
                let codFromUrl = urlParams.get('cod_materia');
                
                // Se não encontrou na query string, tenta extrair da URL completa
                if (!codFromUrl) {
                    const fullUrl = window.location.href;
                    const match = fullUrl.match(/[?&]cod_materia=([^&]+)/);
                    if (match) {
                        codFromUrl = decodeURIComponent(match[1]);
                    }
                }
                
                if (codFromUrl) {
                    APP_DATA.cod_materia = codFromUrl;
                    console.log('[loadPastaDigitalData] cod_materia completado da URL:', codFromUrl);
                } else {
                    console.warn('[loadPastaDigitalData] cod_materia não encontrado na URL. URL completa:', window.location.href, 'Search:', window.location.search);
                }
            }
            
            // Completa portal_url construindo da URL atual se estiver faltando ou vazio
            if (!APP_DATA.portal_url || APP_DATA.portal_url === '' || APP_DATA.portal_url === null || APP_DATA.portal_url === undefined) {
                try {
                    const currentUrl = window.location.href;
                    const urlObj = new URL(currentUrl);
                    // Remove o último segmento (pasta_digital ou @@pasta_digital)
                    const pathParts = urlObj.pathname.split('/').filter(p => p);
                    if (pathParts.length > 0) {
                        // Remove 'pasta_digital' ou '@@pasta_digital' se for o último
                        const lastPart = pathParts[pathParts.length - 1];
                        if (lastPart === 'pasta_digital' || lastPart === '@@pasta_digital') {
                            pathParts.pop();
                        }
                    }
                    APP_DATA.portal_url = urlObj.origin + '/' + pathParts.join('/');
                    console.log('[loadPastaDigitalData] portal_url construído:', APP_DATA.portal_url);
                } catch (e) {
                    console.warn('Erro ao construir portal_url:', e);
                    // Fallback mais simples
                    const path = window.location.pathname;
                    const basePath = path.substring(0, path.lastIndexOf('/'));
                    APP_DATA.portal_url = window.location.origin + basePath;
                    console.log('[loadPastaDigitalData] portal_url (fallback):', APP_DATA.portal_url);
                }
            }
            
            // Completa action se estiver faltando
            if (!APP_DATA.action || APP_DATA.action === '' || APP_DATA.action === null || APP_DATA.action === undefined) {
                APP_DATA.action = urlParams.get('action') || 'pasta';
            }
            
            console.log('[loadPastaDigitalData] Verificando dados injetados:', {
                hasAPP_DATA: typeof APP_DATA !== 'undefined',
                hasPortalUrl: APP_DATA && APP_DATA.portal_url && APP_DATA.portal_url !== '',
                hasCodMateria: APP_DATA && APP_DATA.cod_materia && APP_DATA.cod_materia !== '',
                codMateriaValue: APP_DATA ? APP_DATA.cod_materia : null,
                portalUrlValue: APP_DATA ? APP_DATA.portal_url : null,
                hasPasta: APP_DATA && APP_DATA.pasta !== undefined,
                pastaType: APP_DATA && typeof APP_DATA.pasta,
                pastaKeys: APP_DATA && APP_DATA.pasta ? Object.keys(APP_DATA.pasta) : null,
                hasInjectedData: hasInjectedData,
                APP_DATA_keys: APP_DATA ? Object.keys(APP_DATA) : null
            });
            
            // Se tem pasta e conseguiu completar cod_materia e portal_url, usa dados injetados
            // Verifica se os valores não são null, undefined ou strings vazias
            const hasValidCodMateria = APP_DATA.cod_materia && APP_DATA.cod_materia !== '' && APP_DATA.cod_materia !== null && APP_DATA.cod_materia !== undefined;
            const hasValidPortalUrl = APP_DATA.portal_url && APP_DATA.portal_url !== '' && APP_DATA.portal_url !== null && APP_DATA.portal_url !== undefined;
            
            console.log('[loadPastaDigitalData] Validação final:', {
                hasInjectedData: hasInjectedData,
                hasValidCodMateria: hasValidCodMateria,
                hasValidPortalUrl: hasValidPortalUrl,
                cod_materia: APP_DATA.cod_materia,
                portal_url: APP_DATA.portal_url,
                pasta: APP_DATA.pasta
            });
            
            if (hasInjectedData && hasValidCodMateria && hasValidPortalUrl) {
                console.log('[loadPastaDigitalData] Usando dados injetados pelo servidor (completados)');
                // Verifica se precisa gerar processo antes de esconder loading
                var pasta = APP_DATA.pasta || {};
                var hasDocuments = pasta.documentos && pasta.documentos.length > 0;
                var isAsync = pasta.async === true;
                
                // Se precisa gerar, mostra monitor em vez de esconder loading
                if (!hasDocuments || isAsync) {
                    console.log('[loadPastaDigitalData] Processo precisa ser gerado, mostrando monitor');
                    document.getElementById('loading-state').style.display = 'none';
                    showAsyncMonitor({
                        task_id: pasta.task_id || null,
                        status: pasta.status || 'PENDING',
                        async: true
                    });
                } else {
                    document.getElementById('loading-state').style.display = 'none';
                }
                
                // Atualiza favicon com portal_url se disponível
                if (typeof setFavicon === 'function' && APP_DATA.portal_url) {
                    setFavicon(APP_DATA.portal_url);
                }
                
                updateStaticResources(APP_DATA.portal_url);
                updateInterface({
                    cod_materia: APP_DATA.cod_materia,
                    action: APP_DATA.action || 'pasta',
                    materia: APP_DATA.materia || {},
                    pasta: pasta,
                    portal_config: APP_DATA.portal_config || {},
                    materias_relacionadas: APP_DATA.materias_relacionadas || {},
                    documentos_administrativos: APP_DATA.documentos_administrativos || [],
                    normas_juridicas: APP_DATA.normas_juridicas || [],
                    portal_url: APP_DATA.portal_url
                });
                initialized = true;
                loadingInProgress = false;
                return;
            } else {
                if (!hasInjectedData) {
                    console.warn('[loadPastaDigitalData] Dados não foram injetados pelo servidor');
                } else if (!hasValidCodMateria) {
                    console.warn('[loadPastaDigitalData] cod_materia inválido:', APP_DATA.cod_materia);
                } else if (!hasValidPortalUrl) {
                    console.warn('[loadPastaDigitalData] portal_url inválido:', APP_DATA.portal_url);
                }
            }
            
            // Fallback: carrega via API apenas se realmente necessário
            // urlParams já foi declarado acima, apenas reutiliza
            let cod_materia = urlParams.get('cod_materia') || APP_DATA.cod_materia;
            
            // Se ainda não encontrou, tenta extrair da URL completa
            if (!cod_materia) {
                const fullUrl = window.location.href;
                const match = fullUrl.match(/[?&]cod_materia=([^&]+)/);
                if (match) {
                    cod_materia = decodeURIComponent(match[1]);
                }
            }
            
            const action = urlParams.get('action') || APP_DATA.action || 'pasta';
            
            if (!cod_materia) {
                showError('Parâmetro cod_materia é obrigatório');
                return;
            }
            
            // Se já temos pasta injetada mas faltam outros campos, tenta usar o que temos
            // e só busca via API se realmente necessário
            if (hasInjectedData && APP_DATA.pasta && APP_DATA.pasta.async && APP_DATA.pasta.task_id) {
                console.log('[loadPastaDigitalData] Usando dados parcialmente injetados (modo assíncrono)');
                // Se está em modo assíncrono, podemos usar os dados parciais
                if (!APP_DATA.cod_materia) APP_DATA.cod_materia = cod_materia;
                if (!APP_DATA.portal_url) {
                    try {
                        const urlObj = new URL(window.location.href);
                        const pathParts = urlObj.pathname.split('/').filter(p => p);
                        if (pathParts.length > 0) pathParts.pop();
                        APP_DATA.portal_url = urlObj.origin + '/' + pathParts.join('/');
                    } catch (e) {
                        APP_DATA.portal_url = window.location.origin;
                    }
                }
                
                // Verifica se precisa gerar processo antes de esconder loading
                var pasta = APP_DATA.pasta || {};
                var hasDocuments = pasta.documentos && pasta.documentos.length > 0;
                var isAsync = pasta.async === true;
                
                // Se precisa gerar, mostra monitor em vez de esconder loading
                if (!hasDocuments || isAsync) {
                    console.log('[loadPastaDigitalData] Processo precisa ser gerado (modo assíncrono), mostrando monitor');
                    document.getElementById('loading-state').style.display = 'none';
                    showAsyncMonitor({
                        task_id: pasta.task_id || null,
                        status: pasta.status || 'PENDING',
                        async: true
                    });
                } else {
                    document.getElementById('loading-state').style.display = 'none';
                }
                
                // Atualiza favicon com portal_url se disponível
                if (typeof setFavicon === 'function' && APP_DATA.portal_url) {
                    setFavicon(APP_DATA.portal_url);
                }
                
                updateStaticResources(APP_DATA.portal_url);
                updateInterface({
                    cod_materia: APP_DATA.cod_materia,
                    action: APP_DATA.action || action,
                    materia: APP_DATA.materia || {},
                    pasta: pasta,
                    portal_config: APP_DATA.portal_config || {},
                    materias_relacionadas: APP_DATA.materias_relacionadas || {},
                    documentos_administrativos: APP_DATA.documentos_administrativos || [],
                    normas_juridicas: APP_DATA.normas_juridicas || [],
                    portal_url: APP_DATA.portal_url
                });
                initialized = true;
                loadingInProgress = false;
                return;
            }
            
            console.log('[loadPastaDigitalData] Dados não injetados ou incompletos, carregando via API');
            
            if (typeof APP_DATA === 'undefined') {
                APP_DATA = {
                    cod_materia: null,
                    portal_url: null,
                    pasta: null,
                    materia: null,
                    portal_config: null,
                    materias_relacionadas: null,
                    documentos_administrativos: null,
                    normas_juridicas: null
                };
            }
            
            APP_DATA.cod_materia = cod_materia;
            
            try {
                // Constrói URL correta: remove /consultas/materia se existir
                let baseUrl = APP_DATA.portal_url || window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/');
                if (baseUrl.includes('/consultas/materia')) {
                    baseUrl = baseUrl.replace('/consultas/materia', '');
                }
                baseUrl = baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;
                const apiUrl = baseUrl + '/@@pasta_digital_data?cod_materia=' + encodeURIComponent(cod_materia) + '&action=' + encodeURIComponent(action);
                
                console.log('[loadPastaDigitalData] Fazendo fetch para:', apiUrl);
                
                const response = await fetch(apiUrl);
                if (!response.ok) {
                    throw new Error('Erro HTTP: ' + response.status);
                }
                const data = await response.json();
                
                if (!data.success) {
                    showError(data.error || 'Erro ao carregar dados');
                    return;
                }
                
                // Verifica se já existe uma task em progresso antes de atualizar
                if (data.pasta && data.pasta.async && data.pasta.task_id) {
                    // Se já tem task_id sendo monitorada OU se já existe uma task sendo monitorada, não atualiza
                    if ((currentTaskId === data.pasta.task_id && pollInterval) || 
                        (currentTaskId && currentTaskId !== data.pasta.task_id && pollInterval)) {
                        console.log('[loadPastaDigitalData] Task já está sendo monitorada, não atualizando. Task atual:', currentTaskId, 'Nova task:', data.pasta.task_id);
                        // Apenas atualiza outros dados, mas mantém a pasta atual
                        APP_DATA.portal_url = data.portal_url;
                        APP_DATA.materia = data.materia;
                        APP_DATA.portal_config = data.portal_config;
                        APP_DATA.materias_relacionadas = data.materias_relacionadas;
                        APP_DATA.documentos_administrativos = data.documentos_administrativos;
                        APP_DATA.normas_juridicas = data.normas_juridicas;
                        updateStaticResources(data.portal_url);
                        // Não chama updateInterface para evitar reiniciar o monitor
                        initialized = true;
                        loadingInProgress = false;
                        return;
                    }
                }
                
                APP_DATA.portal_url = data.portal_url;
                APP_DATA.pasta = data.pasta;
                APP_DATA.materia = data.materia;
                APP_DATA.portal_config = data.portal_config;
                APP_DATA.materias_relacionadas = data.materias_relacionadas;
                APP_DATA.documentos_administrativos = data.documentos_administrativos;
                APP_DATA.normas_juridicas = data.normas_juridicas;
                
                updateStaticResources(data.portal_url);
                updateInterface(data);
                
                initialized = true;
                
            } catch (error) {
                console.error('Erro ao carregar dados:', error);
                showError('Erro ao carregar dados: ' + error.message);
                initialized = false; // Permite tentar novamente
            } finally {
                loadingInProgress = false;
            }
        }
        
        // Inicialização - garante que só executa uma vez
        var domReady = false;
        
        function initApp() {
            if (domReady) return;
            domReady = true;
            
            // Define o favicon usando o mesmo do sistema
            function setFavicon(portalUrl) {
                var faviconEl = document.getElementById('favicon');
                if (!faviconEl) return;
                
                // Se já tem href definido e não está vazio, não sobrescreve
                if (faviconEl.href && faviconEl.href !== '' && faviconEl.href !== window.location.href) {
                    return;
                }
                
                // Usa portal_url se disponível, senão constrói do caminho atual
                var baseUrl = portalUrl || window.location.origin;
                var basePath = '';
                
                if (portalUrl) {
                    try {
                        var urlObj = new URL(portalUrl);
                        basePath = urlObj.pathname;
                        // Remove barra final se existir
                        if (basePath.endsWith('/')) {
                            basePath = basePath.slice(0, -1);
                        }
                    } catch (e) {
                        basePath = window.location.pathname.split('/').slice(0, -1).join('/');
                    }
                } else {
                    basePath = window.location.pathname.split('/').slice(0, -1).join('/');
                }
                
                if (basePath === '') basePath = '/';
                var faviconPath = basePath + '/favicon.ico';
                
                // Garante que é uma URL absoluta
                if (!faviconPath.startsWith('http')) {
                    faviconPath = window.location.origin + faviconPath;
                }
                
                faviconEl.href = faviconPath;
                console.log('[setFavicon] Favicon definido:', faviconPath);
            }
            
            // Define favicon imediatamente
            setFavicon();
            
            // Verifica se estamos acessando via view Grok (@@pasta_digital) ou HTML estático
            // Se for HTML estático (sem @@pasta_digital na URL), redireciona para @@pasta_digital
            var urlParams = new URLSearchParams(window.location.search);
            var codMateria = urlParams.get('cod_materia');
            var action = urlParams.get('action') || 'pasta';
            var currentPath = window.location.pathname;
            var currentHref = window.location.href;
            var isGrokView = currentPath.includes('@@pasta_digital') || currentHref.includes('@@pasta_digital');
            
            // Se não é view Grok e tem cod_materia, redireciona para @@pasta_digital
            // Isso garante que sempre use a view Grok que injeta os dados
            if (!isGrokView && codMateria) {
                // Constrói a URL base removendo 'pasta_digital' do path
                var pathParts = currentPath.split('/').filter(p => p);
                // Remove 'pasta_digital' se for o último segmento
                if (pathParts.length > 0 && pathParts[pathParts.length - 1] === 'pasta_digital') {
                    pathParts.pop();
                }
                var basePath = pathParts.length > 0 ? '/' + pathParts.join('/') : '';
                var baseUrl = window.location.origin + basePath;
                var redirectUrl = baseUrl + '/@@pasta_digital?cod_materia=' + encodeURIComponent(codMateria) + '&action=' + encodeURIComponent(action);
                
                // Evita loop de redirecionamento verificando se já tentou redirecionar
                if (!sessionStorage.getItem('pasta_digital_redirected')) {
                    sessionStorage.setItem('pasta_digital_redirected', 'true');
                    console.log('[initApp] Redirecionando para view Grok:', redirectUrl);
                    window.location.href = redirectUrl;
                    return; // Para a execução aqui
                } else {
                    // Se já redirecionou mas ainda está aqui, limpa o flag e continua
                    sessionStorage.removeItem('pasta_digital_redirected');
                }
            }
            
            loadPastaDigitalData();
            
            // Adiciona atalhos de teclado
            setupKeyboardShortcuts();
        }
        
        // Função para configurar atalhos de teclado
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Ignora se estiver digitando em um input ou textarea
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    // Permite Enter no input de página
                    if (e.target.id === 'page-input' && (e.key === 'Enter' || e.keyCode === 13)) {
                        return; // Deixa o handler padrão processar
                    }
                    // Ignora outros atalhos quando em input
                    if (e.target.id !== 'page-input') return;
                }
                
                // Atalhos de navegação de página
                if (e.key === 'ArrowLeft' || e.keyCode === 37) {
                    if (e.ctrlKey || e.metaKey) {
                        // Ctrl/Cmd + ← : Documento anterior
                        e.preventDefault();
                        prevDocumento();
                    } else {
                        // ← : Página anterior
                        e.preventDefault();
                        prevPagina();
                    }
                } else if (e.key === 'ArrowRight' || e.keyCode === 39) {
                    if (e.ctrlKey || e.metaKey) {
                        // Ctrl/Cmd + → : Próximo documento
                        e.preventDefault();
                        nextDocumento();
                    } else {
                        // → : Próxima página
                        e.preventDefault();
                        nextPagina();
                    }
                } else if (e.key === 'Home' || (e.keyCode === 36 && !e.ctrlKey)) {
                    // Home: Primeira página
                    e.preventDefault();
                    goToPage(1);
                } else if (e.key === 'End' || (e.keyCode === 35 && !e.ctrlKey)) {
                    // End: Última página
                    e.preventDefault();
                    goToPage(totalPages);
                } else if ((e.key === 'd' || e.key === 'D') && (e.ctrlKey || e.metaKey)) {
                    // Ctrl/Cmd + D: Download
                    e.preventDefault();
                    var downloadBtn = document.getElementById('btn-download');
                    if (downloadBtn && downloadBtn.href) {
                        window.open(downloadBtn.href, '_blank');
                        showToast('info', 'Download Iniciado', 'O download do PDF integral foi iniciado', 2000);
                    }
                } else if (e.key === '?' || (e.keyCode === 191 && e.shiftKey)) {
                    // ? : Mostra ajuda de atalhos
                    e.preventDefault();
                    showKeyboardShortcutsHelp();
                }
            });
        }
        
        // Função para mostrar ajuda de atalhos
        function showKeyboardShortcutsHelp() {
            var helpText = 'Atalhos de Teclado:\n\n' +
                          '← → : Navegar entre páginas\n' +
                          'Ctrl/Cmd + ← → : Navegar entre documentos\n' +
                          'Home/End : Primeira/Última página\n' +
                          'Ctrl/Cmd + D : Download PDF\n' +
                          '? : Mostrar esta ajuda';
            
            showToast('info', 'Atalhos de Teclado', helpText.replace(/\n/g, '<br>'), 5000);
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initApp);
        } else {
            // DOM já está pronto
            initApp();
        }
        
        // Previne múltiplas execuções mesmo se o evento for disparado várias vezes
        window.addEventListener('load', function() {
            if (!initialized && !domReady) {
                initApp();
            }
        }, { once: true });
    </script>
</body>
</html>
